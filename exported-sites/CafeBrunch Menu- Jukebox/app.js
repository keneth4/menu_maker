
const DATA = {"meta":{"slug":"cafebrunch-menu","name":"CafeBrunch Menu","restaurantName":{"es":"Cafe Aurora","en":"Cafe Aurora"},"title":{"es":"Menu Brunch de la Casa","en":"House Brunch Menu"},"fontFamily":"Cinzel","fontSource":"","template":"jukebox","locales":["es","en","de"],"defaultLocale":"en","currency":"MXN","currencyPosition":"left","identityMode":"text","logoSrc":"","backgroundCarouselSeconds":9,"backgroundDisplayMode":"section","scrollSensitivity":{"item":4,"section":4}},"backgrounds":[{"id":"bg-1770216523927","label":"Cafe","src":"assets/derived/backgrounds/backery-outside-2014d5-md.gif","type":"image","originalSrc":"assets/originals/backgrounds/coffe-drops-544ca0.gif","derived":{"profileId":"ffmpeg-v8-background-2of3-animated-gif","medium":{"gif":"assets/derived/backgrounds/backery-outside-2014d5-md.gif"},"large":{"gif":"assets/derived/backgrounds/backery-outside-2014d5-md.gif"}}},{"id":"bg-1770216805499","label":"drops","src":"assets/derived/backgrounds/coffe-drops-544ca0-md.gif","type":"image","originalSrc":"assets/originals/backgrounds/backery-outside-2014d5.gif","derived":{"profileId":"ffmpeg-v8-background-2of3-animated-gif","medium":{"gif":"assets/derived/backgrounds/coffe-drops-544ca0-md.gif"},"large":{"gif":"assets/derived/backgrounds/coffe-drops-544ca0-md.gif"}}}],"categories":[{"id":"section-pnqps1","name":{"es":"Pastelería","en":"Pastries"},"items":[{"id":"dish-1770216523928-87jyg","name":{"es":"Muffin de Pistache","en":"Pistachio Muffin"},"description":{"es":"Muffin suave de vainilla con centro cremoso de pistache tostado.","en":"Soft vanilla muffin with a creamy roasted pistachio center."},"longDescription":{"es":"El pistache se cultiva desde hace milenios y en el Mediterráneo inspiró una gran tradición repostera; esta versión celebra su perfil tostado y aromático.","en":"Pistachios have been cultivated for millennia and inspired a rich Mediterranean pastry tradition; this version highlights their toasted, aromatic profile."},"price":{"amount":35,"currency":"MXN"},"allergens":[{"id":"gluten","label":{"es":"Gluten","en":"Gluten","de":"Gluten"}},{"id":"egg","label":{"es":"Huevo","en":"Egg","de":"Ei"}},{"id":"dairy","label":{"es":"Lácteos","en":"Dairy","de":"Milchprodukte"}},{"id":"nuts","label":{"es":"Frutos secos","en":"Nuts","de":"Schalenfrüchte"}}],"vegan":false,"media":{"hero360":"assets/derived/items/sample360food-32d517-md.gif","originalHero360":"assets/originals/items/sample360food-32d517.gif","rotationDirection":"cw","gallery":[],"scrollAnimationMode":"hero360","scrollAnimationSrc":"","responsive":{"small":"assets/derived/items/sample360food-32d517-md.gif","medium":"assets/derived/items/sample360food-32d517-md.gif","large":"assets/derived/items/sample360food-32d517-md.gif"},"derived":{"profileId":"ffmpeg-v12-item-2of3-animated-gif-detail-original","medium":{"gif":"assets/derived/items/sample360food-32d517-md.gif"},"large":{"gif":"assets/derived/items/sample360food-32d517-md.gif"}}},"priceVisible":true},{"id":"dish-1770217436244","name":{"es":"Galleta Blanco y Negro","en":"Black-and-White Cookie"},"description":{"es":"Galleta tipo pastel, suave y densa, con glaseado de vainilla y chocolate.","en":"Soft, cake-like cookie finished with vanilla and chocolate icing."},"longDescription":{"es":"Este clásico neoyorquino se volvió popular a inicios del siglo XX y sigue siendo un símbolo de cafetería urbana.","en":"This New York classic rose to popularity in the early 20th century and remains an urban bakery icon."},"price":{"amount":30,"currency":"MXN"},"allergens":[{"id":"gluten","label":{"es":"Gluten","en":"Gluten","de":"Gluten"}},{"id":"egg","label":{"es":"Huevo","en":"Egg","de":"Ei"}},{"id":"dairy","label":{"es":"Lácteos","en":"Dairy","de":"Milchprodukte"}}],"vegan":false,"media":{"hero360":"assets/derived/items/b-w-cookies-45dbd5-md.gif","originalHero360":"assets/originals/items/b-w-cookies-45dbd5.gif","rotationDirection":"cw","gallery":[],"scrollAnimationMode":"hero360","scrollAnimationSrc":"","responsive":{"small":"assets/derived/items/b-w-cookies-45dbd5-md.gif","medium":"assets/derived/items/b-w-cookies-45dbd5-md.gif","large":"assets/derived/items/b-w-cookies-45dbd5-md.gif"},"derived":{"profileId":"ffmpeg-v12-item-2of3-animated-gif-detail-original","medium":{"gif":"assets/derived/items/b-w-cookies-45dbd5-md.gif"},"large":{"gif":"assets/derived/items/b-w-cookies-45dbd5-md.gif"}}},"priceVisible":true},{"id":"dish-1770217647423","name":{"es":"Dona de Frutos Rojos","en":"Berry Glazed Donut"},"description":{"es":"Dona esponjosa con relleno de frutos rojos y glaseado brillante de mora.","en":"Fluffy donut filled with mixed berries and finished with a glossy blackberry glaze."},"longDescription":{"es":"Inspirada en la tradición de masas fritas que viajó de Europa a América, combina un interior ligero con un final frutal intenso.","en":"Inspired by the fried-dough tradition that traveled from Europe to the Americas, it pairs a light crumb with a bold berry finish."},"price":{"amount":30,"currency":"MXN"},"allergens":[{"id":"gluten","label":{"es":"Gluten","en":"Gluten","de":"Gluten"}},{"id":"egg","label":{"es":"Huevo","en":"Egg","de":"Ei"}},{"id":"dairy","label":{"es":"Lácteos","en":"Dairy","de":"Milchprodukte"}}],"vegan":false,"media":{"hero360":"assets/derived/items/all-berry-donut-a85640-md.gif","originalHero360":"assets/originals/items/all-berry-donut-a85640.gif","rotationDirection":"cw","gallery":[],"scrollAnimationMode":"hero360","scrollAnimationSrc":"","responsive":{"small":"assets/derived/items/all-berry-donut-a85640-md.gif","medium":"assets/derived/items/all-berry-donut-a85640-md.gif","large":"assets/derived/items/all-berry-donut-a85640-md.gif"},"derived":{"profileId":"ffmpeg-v12-item-2of3-animated-gif-detail-original","medium":{"gif":"assets/derived/items/all-berry-donut-a85640-md.gif"},"large":{"gif":"assets/derived/items/all-berry-donut-a85640-md.gif"}}},"priceVisible":true},{"id":"dish-1770218071272","name":{"es":"Hotcakes de Arándano","en":"Blueberry Pancakes"},"description":{"es":"Hotcakes esponjosos con compota de arándano azul y mantequilla batida.","en":"Fluffy pancakes topped with blueberry compote and whipped butter."},"longDescription":{"es":"Los hotcakes tienen raíces antiguas: en Grecia ya se preparaban versiones de sartén con harina y miel; hoy los servimos en clave brunch.","en":"Pancakes have ancient roots: Greek cooks were already making griddled versions with flour and honey; this is our brunch take."},"price":{"amount":55,"currency":"MXN"},"allergens":[{"id":"gluten","label":{"es":"Gluten","en":"Gluten","de":"Gluten"}},{"id":"egg","label":{"es":"Huevo","en":"Egg","de":"Ei"}},{"id":"dairy","label":{"es":"Lácteos","en":"Dairy","de":"Milchprodukte"}}],"vegan":false,"media":{"hero360":"assets/derived/items/blue-berry-pancakes-6028f0-md.gif","originalHero360":"assets/originals/items/blue-berry-pancakes-6028f0.gif","rotationDirection":"cw","gallery":[],"scrollAnimationMode":"hero360","scrollAnimationSrc":"","responsive":{"small":"assets/derived/items/blue-berry-pancakes-6028f0-md.gif","medium":"assets/derived/items/blue-berry-pancakes-6028f0-md.gif","large":"assets/derived/items/blue-berry-pancakes-6028f0-md.gif"},"derived":{"profileId":"ffmpeg-v12-item-2of3-animated-gif-detail-original","medium":{"gif":"assets/derived/items/blue-berry-pancakes-6028f0-md.gif"},"large":{"gif":"assets/derived/items/blue-berry-pancakes-6028f0-md.gif"}}},"priceVisible":true},{"id":"dish-1770218671234","name":{"es":"Pay de Caramelo","en":"Salted Caramel Pie"},"description":{"es":"Pay de mantequilla con relleno de caramelo y crema ligeramente salada.","en":"Buttery pie with a silky caramel filling and a lightly salted cream finish."},"longDescription":{"es":"Retoma la estructura clásica de un pie horneado y la lleva a un perfil dulce-salado para equilibrar cada bocado.","en":"It keeps the classic baked pie structure and leans into a sweet-salty profile for balance in every bite."},"price":{"amount":45,"currency":"MXN"},"allergens":[{"id":"gluten","label":{"es":"Gluten","en":"Gluten","de":"Gluten"}},{"id":"egg","label":{"es":"Huevo","en":"Egg","de":"Ei"}},{"id":"dairy","label":{"es":"Lácteos","en":"Dairy","de":"Milchprodukte"}}],"vegan":false,"media":{"hero360":"assets/derived/items/caramel-pie-6e6f4b-md.gif","originalHero360":"assets/originals/items/caramel-pie-6e6f4b.gif","rotationDirection":"cw","gallery":[],"scrollAnimationMode":"hero360","scrollAnimationSrc":"","responsive":{"small":"assets/derived/items/caramel-pie-6e6f4b-md.gif","medium":"assets/derived/items/caramel-pie-6e6f4b-md.gif","large":"assets/derived/items/caramel-pie-6e6f4b-md.gif"},"derived":{"profileId":"ffmpeg-v12-item-2of3-animated-gif-detail-original","medium":{"gif":"assets/derived/items/caramel-pie-6e6f4b-md.gif"},"large":{"gif":"assets/derived/items/caramel-pie-6e6f4b-md.gif"}}},"priceVisible":true},{"id":"dish-1770219007092","name":{"es":"Cheesecake de Moras (Entero)","en":"Whole Mixed-Berry Cheesecake"},"description":{"es":"Cheesecake completo de textura cremosa, con coulis de moras y base crujiente.","en":"Whole creamy cheesecake with mixed-berry coulis and a crisp crust."},"longDescription":{"es":"El cheesecake nace en la Antigüedad griega y evolucionó hasta estilos modernos como el neoyorquino; esta versión privilegia cremosidad y fruta.","en":"Cheesecake traces back to ancient Greece and later evolved into modern styles like New York’s; this version focuses on creaminess and fruit."},"price":{"amount":350,"currency":"MXN"},"allergens":[{"id":"gluten","label":{"es":"Gluten","en":"Gluten","de":"Gluten"}},{"id":"egg","label":{"es":"Huevo","en":"Egg","de":"Ei"}},{"id":"dairy","label":{"es":"Lácteos","en":"Dairy","de":"Milchprodukte"}}],"vegan":false,"media":{"hero360":"assets/derived/items/full-cheescake-3d5f52-md.gif","originalHero360":"assets/originals/items/full-cheescake-3d5f52.gif","rotationDirection":"cw","gallery":[],"scrollAnimationMode":"hero360","scrollAnimationSrc":"","responsive":{"small":"assets/derived/items/full-cheescake-3d5f52-md.gif","medium":"assets/derived/items/full-cheescake-3d5f52-md.gif","large":"assets/derived/items/full-cheescake-3d5f52-md.gif"},"derived":{"profileId":"ffmpeg-v12-item-2of3-animated-gif-detail-original","medium":{"gif":"assets/derived/items/full-cheescake-3d5f52-md.gif"},"large":{"gif":"assets/derived/items/full-cheescake-3d5f52-md.gif"}}},"priceVisible":true},{"id":"dish-1770219339360","name":{"es":"Cheesecake de Frambuesa","en":"Raspberry Cheesecake"},"description":{"es":"Rebanada de cheesecake con frambuesa, base de galleta y acabado de crema ligera.","en":"Cheesecake slice with raspberry, cookie crust, and a light cream finish."},"longDescription":{"es":"Un clásico de cafetería contemporánea: queso crema, fruta ácida y una base crujiente para dar contraste.","en":"A contemporary coffee-shop classic: cream cheese, tart fruit, and a crisp crust for contrast."},"price":{"amount":35,"currency":"MXN"},"allergens":[{"id":"gluten","label":{"es":"Gluten","en":"Gluten","de":"Gluten"}},{"id":"egg","label":{"es":"Huevo","en":"Egg","de":"Ei"}},{"id":"dairy","label":{"es":"Lácteos","en":"Dairy","de":"Milchprodukte"}}],"vegan":false,"media":{"hero360":"assets/derived/items/raspberry-cheesecake-pie-55d70e-md.gif","originalHero360":"assets/originals/items/raspberry-cheesecake-pie-55d70e.gif","rotationDirection":"cw","gallery":[],"scrollAnimationMode":"hero360","scrollAnimationSrc":"","responsive":{"small":"assets/derived/items/raspberry-cheesecake-pie-55d70e-md.gif","medium":"assets/derived/items/raspberry-cheesecake-pie-55d70e-md.gif","large":"assets/derived/items/raspberry-cheesecake-pie-55d70e-md.gif"},"derived":{"profileId":"ffmpeg-v12-item-2of3-animated-gif-detail-original","medium":{"gif":"assets/derived/items/raspberry-cheesecake-pie-55d70e-md.gif"},"large":{"gif":"assets/derived/items/raspberry-cheesecake-pie-55d70e-md.gif"}}},"priceVisible":true},{"id":"dish-1770219635727","name":{"es":"Sándwich de Helado Napolitano","en":"Neapolitan Ice Cream Sandwich"},"description":{"es":"Helado napolitano entre galletas de chocolate suave, servido bien frío.","en":"Neapolitan ice cream between soft chocolate cookies, served extra cold."},"longDescription":{"es":"Los sándwiches de helado se popularizaron en Nueva York a finales del siglo XIX; esta versión retoma ese formato con sabor clásico.","en":"Ice cream sandwiches became popular in New York in the late 19th century; this version keeps that classic format and flavor."},"price":{"amount":30,"currency":"MXN"},"allergens":[{"id":"gluten","label":{"es":"Gluten","en":"Gluten","de":"Gluten"}},{"id":"egg","label":{"es":"Huevo","en":"Egg","de":"Ei"}},{"id":"dairy","label":{"es":"Lácteos","en":"Dairy","de":"Milchprodukte"}}],"vegan":true,"media":{"hero360":"assets/derived/items/ice-cream-sandwich-5545c1-md.webp","originalHero360":"assets/originals/items/ice-cream-sandwich-5545c1.webp","rotationDirection":"ccw","gallery":[],"scrollAnimationMode":"hero360","scrollAnimationSrc":"","responsive":{"small":"assets/derived/items/ice-cream-sandwich-5545c1-md.webp","medium":"assets/derived/items/ice-cream-sandwich-5545c1-md.webp","large":"assets/derived/items/ice-cream-sandwich-5545c1-md.webp"},"derived":{"profileId":"ffmpeg-v11-item-2of3-animated-webp-detail-original","medium":{"webp":"assets/derived/items/ice-cream-sandwich-5545c1-md.webp"},"large":{"webp":"assets/derived/items/ice-cream-sandwich-5545c1-md.webp"}}},"priceVisible":true}],"backgroundId":"bg-1770216523927"},{"id":"section-izp9v9","name":{"es":"Brunch","en":"Brunch"},"items":[{"id":"dish-1770216523929-l8vq2","name":{"es":"Sándwich de Tocino y Jamón","en":"Bacon & Ham Sandwich"},"description":{"es":"Pan tostado con jamón, tocino crujiente, jitomate y aderezo cremoso.","en":"Toasted bread with ham, crispy bacon, tomato, and a creamy dressing."},"longDescription":{"es":"De inspiración deli, prioriza contraste de texturas entre pan dorado, proteína ahumada y frescura vegetal.","en":"Deli-inspired and texture-driven: toasted bread, smoky protein, and fresh vegetables in balance."},"price":{"amount":40,"currency":"MXN"},"allergens":[{"id":"gluten","label":{"es":"Gluten","en":"Gluten","de":"Gluten"}},{"id":"egg","label":{"es":"Huevo","en":"Egg","de":"Ei"}}],"vegan":false,"media":{"hero360":"assets/derived/items/sandwich-bacon-3730bb-md.gif","originalHero360":"assets/originals/items/sandwich-bacon-3730bb.gif","rotationDirection":"ccw","gallery":[],"scrollAnimationMode":"hero360","scrollAnimationSrc":"","responsive":{"small":"assets/derived/items/sandwich-bacon-3730bb-md.gif","medium":"assets/derived/items/sandwich-bacon-3730bb-md.gif","large":"assets/derived/items/sandwich-bacon-3730bb-md.gif"},"derived":{"profileId":"ffmpeg-v12-item-2of3-animated-gif-detail-original","medium":{"gif":"assets/derived/items/sandwich-bacon-3730bb-md.gif"},"large":{"gif":"assets/derived/items/sandwich-bacon-3730bb-md.gif"}}},"priceVisible":true},{"id":"dish-1770220621189","name":{"es":"Sándwich de Pollo Jerk","en":"Jerk Chicken Sandwich"},"description":{"es":"Pechuga de pollo marinada con especias jerk, lechuga fresca y mayonesa de la casa.","en":"Chicken breast marinated in jerk spices with crisp lettuce and house mayo."},"longDescription":{"es":"El estilo jerk nació en Jamaica con técnicas indígenas y maroon; su sello es el picor aromático del allspice y el chile.","en":"Jerk cooking was born in Jamaica from Indigenous and Maroon techniques, known for the aromatic heat of allspice and chile."},"price":{"amount":55,"currency":"MXN"},"allergens":[{"id":"gluten","label":{"es":"Gluten","en":"Gluten","de":"Gluten"}},{"id":"egg","label":{"es":"Huevo","en":"Egg","de":"Ei"}}],"vegan":false,"media":{"hero360":"assets/derived/items/jerk-chicken-sandwich-62875b-md.webp","originalHero360":"assets/originals/items/jerk-chicken-sandwich-62875b.webp","rotationDirection":"ccw","gallery":[],"scrollAnimationMode":"hero360","scrollAnimationSrc":"","responsive":{"small":"assets/derived/items/jerk-chicken-sandwich-62875b-md.webp","medium":"assets/derived/items/jerk-chicken-sandwich-62875b-md.webp","large":"assets/derived/items/jerk-chicken-sandwich-62875b-md.webp"},"derived":{"profileId":"ffmpeg-v11-item-2of3-animated-webp-detail-original","medium":{"webp":"assets/derived/items/jerk-chicken-sandwich-62875b-md.webp"},"large":{"webp":"assets/derived/items/jerk-chicken-sandwich-62875b-md.webp"}}},"priceVisible":true},{"id":"dish-1770220835963","name":{"es":"Sándwich de Pollo Empanizado","en":"Crispy Breaded Chicken Sandwich"},"description":{"es":"Filete de pollo empanizado y crujiente, con lechuga, jitomate y mayonesa.","en":"Crispy breaded chicken fillet with lettuce, tomato, and mayo."},"longDescription":{"es":"Basado en la tradición de la milanesa y el pan crujiente, busca un bocado jugoso por dentro y dorado por fuera.","en":"Built on the tradition of breaded cutlets and crusty bread, aiming for juicy inside and golden crunch outside."},"price":{"amount":50,"currency":"MXN"},"allergens":[{"id":"gluten","label":{"es":"Gluten","en":"Gluten","de":"Gluten"}},{"id":"egg","label":{"es":"Huevo","en":"Egg","de":"Ei"}}],"vegan":false,"media":{"hero360":"assets/derived/items/sandwich-filete-de-pollo-empanizado-41fbf2-md.gif","originalHero360":"assets/originals/items/sandwich-filete-de-pollo-empanizado-41fbf2.gif","rotationDirection":"cw","gallery":[],"scrollAnimationMode":"hero360","scrollAnimationSrc":"","responsive":{"small":"assets/derived/items/sandwich-filete-de-pollo-empanizado-41fbf2-md.gif","medium":"assets/derived/items/sandwich-filete-de-pollo-empanizado-41fbf2-md.gif","large":"assets/derived/items/sandwich-filete-de-pollo-empanizado-41fbf2-md.gif"},"derived":{"profileId":"ffmpeg-v12-item-2of3-animated-gif-detail-original","medium":{"gif":"assets/derived/items/sandwich-filete-de-pollo-empanizado-41fbf2-md.gif"},"large":{"gif":"assets/derived/items/sandwich-filete-de-pollo-empanizado-41fbf2-md.gif"}}},"priceVisible":true},{"id":"dish-1770221040005","name":{"es":"Torta de Jamón de Pavo","en":"Turkey Ham Torta"},"description":{"es":"Bolillo crujiente con jamón de pavo, aguacate, jitomate y frijoles refritos.","en":"Crisp bolillo roll with turkey ham, avocado, tomato, and refried beans."},"longDescription":{"es":"La torta mexicana se apoya en el bolillo, pan introducido en la CDMX del siglo XIX con influencia francesa; hoy es emblema callejero.","en":"The Mexican torta relies on bolillo bread, introduced in 19th-century Mexico City with French influence; today it is a street-food staple."},"price":{"amount":50,"currency":"MXN"},"allergens":[{"id":"gluten","label":{"es":"Gluten","en":"Gluten","de":"Gluten"}}],"vegan":false,"media":{"hero360":"assets/derived/items/torta-de-jamon-de-pavo-275306-md.gif","originalHero360":"assets/originals/items/torta-de-jamon-de-pavo-275306.gif","rotationDirection":"cw","gallery":[],"scrollAnimationMode":"hero360","scrollAnimationSrc":"","responsive":{"small":"assets/derived/items/torta-de-jamon-de-pavo-275306-md.gif","medium":"assets/derived/items/torta-de-jamon-de-pavo-275306-md.gif","large":"assets/derived/items/torta-de-jamon-de-pavo-275306-md.gif"},"derived":{"profileId":"ffmpeg-v12-item-2of3-animated-gif-detail-original","medium":{"gif":"assets/derived/items/torta-de-jamon-de-pavo-275306-md.gif"},"large":{"gif":"assets/derived/items/torta-de-jamon-de-pavo-275306-md.gif"}}},"priceVisible":true}],"backgroundId":"bg-1770216805499"}],"sound":{"enabled":false,"theme":"bar-amber","volume":0.6,"map":{}}};
const currencySymbols = {
  MXN: "$", USD: "$", EUR: "€", GBP: "£", JPY: "¥", COP: "$", ARS: "$"
};
const FOCUS_ROWS_WHEEL_STEP_THRESHOLD = 442;
const FOCUS_ROWS_WHEEL_SETTLE_MS = 200;
const FOCUS_ROWS_WHEEL_DELTA_CAP = 140;
const FOCUS_ROWS_TOUCH_DELTA_SCALE = 1.804;
const FOCUS_ROWS_MAX_STEP_PER_INPUT = 0;
const FOCUS_ROWS_TOUCH_INTENT_THRESHOLD = 10;
let locale = DATA.meta.defaultLocale || DATA.meta.locales[0] || "es";
const fontFamily = DATA.meta.fontFamily || "Fraunces";
const fontSource = DATA.meta.fontSource || "";
const backgroundDisplayMode = DATA.meta.backgroundDisplayMode === "section" ? "section" : "carousel";
const fontRoles = DATA.meta.fontRoles || {};
const builtInFontSources = {
  Fraunces: "https://fonts.googleapis.com/css2?family=Fraunces:wght@400;500;700&display=swap",
  Cinzel: "https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;700&display=swap",
  "Cormorant Garamond":
    "https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@400;500;700&display=swap",
  "Playfair Display":
    "https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;500;700&display=swap",
  Poppins: "https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;700&display=swap"
};
const backgrounds = (DATA.backgrounds || []).filter(
  (item) => item?.src && String(item.src).trim().length > 0
);
const backgroundIndexById = new Map(
  backgrounds.map((background, index) => [background.id || "", index])
);
const sectionBackgroundUsage = new Map();
(DATA.categories || []).forEach((category) => {
  const id = String(category?.backgroundId || "").trim();
  if (!id) return;
  sectionBackgroundUsage.set(id, (sectionBackgroundUsage.get(id) || 0) + 1);
});
const sectionBackgroundByCategoryId = new Map(
  (DATA.categories || []).map((category) => {
    const id = String(category?.backgroundId || "").trim();
    const mapped = backgroundIndexById.get(id);
    const isUnique = Boolean(id) && (sectionBackgroundUsage.get(id) || 0) === 1;
    return [category.id, isUnique && typeof mapped === "number" ? mapped : -1];
  })
);
const normalizeBackgroundCarouselSeconds = (value) => {
  const parsed = Number(value);
  if (!Number.isFinite(parsed)) return 9;
  return Math.min(60, Math.max(2, Math.round(parsed)));
};
const backgroundRotationMs = normalizeBackgroundCarouselSeconds(DATA.meta.backgroundCarouselSeconds) * 1000;
let activeBackgroundIndex =
  backgroundDisplayMode === "section"
    ? (() => {
        const firstCategoryId = DATA.categories?.[0]?.id;
        if (!firstCategoryId) return -1;
        const mapped = sectionBackgroundByCategoryId.get(firstCategoryId);
        return typeof mapped === "number" ? mapped : -1;
      })()
    : 0;
let backgroundTimer;
let applyBackgroundState = () => {};
const injectedFontFaceKeys = new Set();
const injectedFontLinks = new Set();
const app = document.getElementById("app");
const modal = document.getElementById("dish-modal");
const modalContent = document.getElementById("dish-modal-content");
let modalMediaCleanup = null;
let modalMediaToken = 0;
let carouselCleanup = [];
let startupLoading = true;
let startupProgress = 0;
let startupToken = 0;
let startupBlockingSourceSet = null;
const JUKEBOX_WHEEL_STEP_THRESHOLD = 442;
const JUKEBOX_WHEEL_SETTLE_MS = 240;
const JUKEBOX_WHEEL_DELTA_CAP = 140;
const JUKEBOX_VERTICAL_DOMINANCE_RATIO = 2.2;
const JUKEBOX_VERTICAL_WHEEL_MIN_PX = 10;
const JUKEBOX_HORIZONTAL_WHEEL_MIN_PX = 0.1;
const JUKEBOX_HORIZONTAL_SECTION_THRESHOLD_PX = 510;
const JUKEBOX_SECTION_WHEEL_COOLDOWN_MS = 240;
const JUKEBOX_HORIZONTAL_GESTURE_IDLE_MS = 240;
const JUKEBOX_TOUCH_DELTA_SCALE = 1.722;
const JUKEBOX_MAX_STEP_PER_INPUT = 0;
const JUKEBOX_TOUCH_INTENT_THRESHOLD = 10;
const INTERACTIVE_GIF_MAX_FRAMES = 72;
const INTERACTIVE_KEEP_ORIGINAL_PLACEMENT = true;
const ROTATE_CUE_RESHOW_IDLE_MS = 3000;
const ROTATE_CUE_LOOP_MS = 5000;
const DEBUG_INTERACTIVE_CENTER = new URLSearchParams(window.location.search).has("debugRotate");
const interactiveDetailBytesCache = new Map();
const interactiveDetailBytesPending = new Map();
const interactiveDetailCenterOffsetCache = new Map();
const detailPrefetchedSources = new Set();
const startupAssetBytes = new Map();
let startupAssetBytesPromise = null;
let startupAssetBytesReady = false;
let detailRotateDirection = -1;
const jukeboxWheelState = new Map();
const focusRowWheelState = new Map();

const textOf = (entry) => entry?.[locale] ?? entry?.[DATA.meta.defaultLocale] ?? "";
const menuTerms = {
  es: { allergens: "Alérgenos", vegan: "Vegano" },
  en: { allergens: "Allergens", vegan: "Vegan" },
  fr: { allergens: "Allergènes", vegan: "Végétalien" },
  pt: { allergens: "Alergênicos", vegan: "Vegano" },
  it: { allergens: "Allergeni", vegan: "Vegano" },
  de: { allergens: "Allergene", vegan: "Vegan" },
  ja: { allergens: "アレルゲン", vegan: "ヴィーガン" },
  ko: { allergens: "알레르겐", vegan: "비건" },
  zh: { allergens: "过敏原", vegan: "纯素" }
};
const getTerm = (key) => {
  const lang = (locale || "").toLowerCase().split("-")[0];
  return (menuTerms[lang] || menuTerms.en)[key];
};
const getAllergenValues = (dish) =>
  (dish.allergens || [])
    .map((entry) => {
      if (!entry) return "";
      if (typeof entry === "string") return entry;
      const lang = (locale || "").toLowerCase();
      const langBase = lang.split("-")[0];
      const defaultLang = (DATA.meta.defaultLocale || "en").toLowerCase();
      const defaultBase = defaultLang.split("-")[0];
      return (
        entry.label?.[lang] ??
        entry.label?.[langBase] ??
        entry.label?.[defaultLang] ??
        entry.label?.[defaultBase] ??
        entry.label?.en ??
        ""
      );
    })
    .filter((value) => value && value.trim().length > 0);
const formatPrice = (amount) => {
  const symbol = currencySymbols[DATA.meta.currency] || DATA.meta.currency;
  const position = DATA.meta.currencyPosition || "left";
  return position === "left" ? symbol + amount : amount + symbol;
};
const getFontStack = (family) => {
  const cleaned = (family || "").replace(/"/g, "");
  const primary = cleaned ? '"' + cleaned + '", ' : "";
  return primary + '"Fraunces", "Georgia", serif';
};
const slugifyFontTokenPart = (value) =>
  String(value || "")
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-+|-+$/g, "");
const hashFontSourceToken = (value) => {
  let hash = 2166136261;
  const text = String(value || "");
  for (let index = 0; index < text.length; index += 1) {
    hash ^= text.charCodeAt(index);
    hash = Math.imul(hash, 16777619);
  }
  return (hash >>> 0).toString(36).slice(0, 6);
};
const deriveFontFamilyFromSource = (source) => {
  const normalized = String(source || "").trim();
  if (!normalized) return "";
  const filename = normalized.split("/").filter(Boolean).pop() || "font";
  const base = filename.replace(/.[a-z0-9]+$/i, "");
  const slug = slugifyFontTokenPart(base).slice(0, 24) || "font";
  return "menu-font-" + slug + "-" + hashFontSourceToken(normalized.toLowerCase());
};
const normalizeFontConfig = (config) => ({
  family: String(config?.family || "").trim(),
  source: String(config?.source || "").trim()
});
const withResolvedFontFamily = (config) =>
  config.source
    ? { family: deriveFontFamilyFromSource(config.source), source: config.source }
    : config;
const getInterfaceFontConfig = () =>
  withResolvedFontFamily(normalizeFontConfig({ family: fontFamily, source: fontSource }));
const getRoleFontConfig = (role) => {
  const identityBaseFont =
    role === "restaurant" || role === "title"
      ? getRoleFontConfig("identity")
      : getInterfaceFontConfig();
  const roleFont = normalizeFontConfig(fontRoles?.[role]);
  return withResolvedFontFamily({
    family: roleFont.family || identityBaseFont.family,
    source: roleFont.source || identityBaseFont.source
  });
};
const getItemFontConfig = (item) => {
  const fallback = getRoleFontConfig("item");
  const itemConfig = normalizeFontConfig(item?.typography?.item);
  return withResolvedFontFamily({
    family: itemConfig.family || fallback.family,
    source: itemConfig.source || fallback.source
  });
};
const collectRuntimeFontConfigs = () => {
  const configs = [];
  const seen = new Set();
  const pushConfig = (config) => {
    const normalized = withResolvedFontFamily(normalizeFontConfig(config));
    if (!normalized.family) return;
    const key = normalized.family + "::" + normalized.source;
    if (seen.has(key)) return;
    seen.add(key);
    configs.push(normalized);
  };
  pushConfig(getInterfaceFontConfig());
  pushConfig(getRoleFontConfig("identity"));
  pushConfig(getRoleFontConfig("restaurant"));
  pushConfig(getRoleFontConfig("title"));
  pushConfig(getRoleFontConfig("section"));
  pushConfig(getRoleFontConfig("item"));
  (DATA.categories || []).forEach((category) => {
    (category.items || []).forEach((item) => {
      pushConfig(getItemFontConfig(item));
    });
  });
  return configs;
};
const ensureFont = () => {
  collectRuntimeFontConfigs().forEach((config) => {
    if (!config.family) return;
    if (config.source) {
      const faceKey = config.family + "::" + config.source;
      if (injectedFontFaceKeys.has(faceKey)) return;
      const ext = config.source.split(".").pop()?.toLowerCase();
      let format = "";
      if (ext === "woff2") format = "woff2";
      if (ext === "woff") format = "woff";
      if (ext === "otf") format = "opentype";
      if (ext === "ttf") format = "truetype";
      const formatLine = format ? ' format("' + format + '")' : "";
      const style = document.createElement("style");
      style.textContent =
        '@font-face { font-family: "' +
        config.family +
        '"; src: url("' +
        config.source +
        '")' +
        formatLine +
        '; font-display: swap; }';
      document.head.appendChild(style);
      injectedFontFaceKeys.add(faceKey);
      return;
    }
    const builtInFontHref = builtInFontSources[config.family] || "";
    if (!builtInFontHref || injectedFontLinks.has(builtInFontHref)) return;
    const link = document.createElement("link");
    link.rel = "stylesheet";
    link.href = builtInFontHref;
    document.head.appendChild(link);
    injectedFontLinks.add(builtInFontHref);
  });
};
const getPreviewFontVars = () => {
  const interfaceFont = getInterfaceFontConfig();
  const identityFont = getRoleFontConfig("identity");
  const restaurantFont = getRoleFontConfig("restaurant");
  const titleFont = getRoleFontConfig("title");
  const sectionFont = getRoleFontConfig("section");
  const itemFont = getRoleFontConfig("item");
  return (
    "--menu-font:" +
    getFontStack(interfaceFont.family) +
    ";--menu-font-ui:" +
    getFontStack(interfaceFont.family) +
    ";--menu-font-identity:" +
    getFontStack(identityFont.family) +
    ";--menu-font-restaurant:" +
    getFontStack(restaurantFont.family) +
    ";--menu-font-title:" +
    getFontStack(titleFont.family) +
    ";--menu-font-section:" +
    getFontStack(sectionFont.family) +
    ";--menu-font-item:" +
    getFontStack(itemFont.family) +
    ";"
  );
};
const getItemFontStyle = (item) => {
  const itemFont = getItemFontConfig(item);
  if (!itemFont.family) return "";
  return "--item-font:" + getFontStack(itemFont.family) + ";";
};
const getSectionBackgroundIndexByCategoryId = (categoryId) => {
  const index = sectionBackgroundByCategoryId.get(categoryId);
  if (typeof index === "number" && index >= 0) return index;
  return -1;
};
const syncBackgroundForSectionIndex = (index) => {
  if (backgroundDisplayMode !== "section") return;
  const category = DATA.categories[index];
  if (!category) return;
  const mappedIndex = getSectionBackgroundIndexByCategoryId(category.id);
  if (mappedIndex === activeBackgroundIndex) return;
  activeBackgroundIndex = mappedIndex;
  applyBackgroundState();
};

const getFocusRowItems = (items) =>
  items.map((item, index) => ({
    item,
    sourceIndex: index,
    key: item.id + "-focus"
  }));
const getJukeboxItems = (items) =>
  items.map((item, index) => ({
    item,
    sourceIndex: index,
    key: item.id + "-jukebox"
  }));
const getCircularOffset = (activeIndex, targetIndex, count) => {
  if (count <= 1) return 0;
  let offset = targetIndex - activeIndex;
  const half = count / 2;
  while (offset > half) offset -= count;
  while (offset < -half) offset += count;
  return offset;
};
const wrapCarouselIndex = (value, count) => {
  if (count <= 0) return 0;
  return ((value % count) + count) % count;
};
const TRANSPARENT_PIXEL_SRC =
  "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1' height='1'/%3E";
const CAROUSEL_MEDIA_ACTIVE_RADIUS = 2.25;
const setCarouselCardMediaState = (card, state) => {
  const media = card?.querySelector(".carousel-media");
  if (!(media instanceof HTMLElement)) return;
  media.classList.toggle("is-loading", state === "loading");
  media.classList.toggle("is-loaded", state === "loaded");
};
const attachCarouselCardMediaListeners = (card, image) => {
  if (image.dataset.mediaListenersAttached === "1") return;
  image.addEventListener("load", () => {
    if (image.dataset.mediaHydrated !== "1") return;
    image.dataset.mediaLoaded = "1";
    setCarouselCardMediaState(card, "loaded");
  });
  image.addEventListener("error", () => {
    if (image.dataset.mediaHydrated !== "1") return;
    image.dataset.mediaLoaded = "1";
    image.removeAttribute("srcset");
    image.src = TRANSPARENT_PIXEL_SRC;
    setCarouselCardMediaState(card, "loaded");
  });
  image.dataset.mediaListenersAttached = "1";
};
const hydrateCarouselCardMedia = (card) => {
  const image = card?.querySelector(".carousel-media img");
  if (!(image instanceof HTMLImageElement)) return;
  const source = (image.dataset.mediaSrc || "").trim();
  if (!source) {
    setCarouselCardMediaState(card, "loaded");
    return;
  }
  if (image.dataset.mediaLoaded === "1" && image.dataset.mediaActiveSource === source) {
    setCarouselCardMediaState(card, "loaded");
    return;
  }
  if (image.dataset.mediaHydrated === "1" && image.dataset.mediaActiveSource === source) {
    setCarouselCardMediaState(card, "loading");
    return;
  }
  image.dataset.mediaHydrated = "1";
  image.dataset.mediaLoaded = "0";
  image.dataset.mediaActiveSource = source;
  setCarouselCardMediaState(card, "loading");
  attachCarouselCardMediaListeners(card, image);
  const srcSet = (image.dataset.mediaSrcset || "").trim();
  if (srcSet) {
    image.setAttribute("srcset", srcSet);
  } else {
    image.removeAttribute("srcset");
  }
  image.setAttribute("fetchpriority", "high");
  image.src = source;
  if (image.complete) {
    image.dataset.mediaLoaded = "1";
    setCarouselCardMediaState(card, "loaded");
  }
};
const maybeHydrateCarouselCardMedia = (card, distance) => {
  if (distance > CAROUSEL_MEDIA_ACTIVE_RADIUS) return;
  const image = card?.querySelector(".carousel-media img");
  if (!(image instanceof HTMLImageElement)) return;
  const source = (image.dataset.mediaSrc || "").trim();
  if (!source) return;
  if (startupLoading) {
    if (!(startupBlockingSourceSet instanceof Set)) return;
    if (startupBlockingSourceSet.size > 0 && !startupBlockingSourceSet.has(source)) return;
  }
  hydrateCarouselCardMedia(card);
};
const normalizeJukeboxWheelDelta = (event) => {
  const modeScale = event.deltaMode === 1 ? 40 : event.deltaMode === 2 ? 240 : 1;
  const scaled = event.deltaY * modeScale;
  return Math.max(-JUKEBOX_WHEEL_DELTA_CAP, Math.min(JUKEBOX_WHEEL_DELTA_CAP, scaled));
};
const normalizeFocusRowWheelDelta = (event) => {
  const modeScale = event.deltaMode === 1 ? 40 : event.deltaMode === 2 ? 240 : 1;
  const scaled = event.deltaX * modeScale;
  return Math.max(-FOCUS_ROWS_WHEEL_DELTA_CAP, Math.min(FOCUS_ROWS_WHEEL_DELTA_CAP, scaled));
};

const IMAGE_DERIVED_FORMAT_PREFERENCE = ["webp","gif"];
const RESPONSIVE_IMAGE_WIDTHS = {"small":480,"medium":960,"large":1440};
const CAROUSEL_VARIANT_PRIORITY = ["medium","large","small"];
const DETAIL_VARIANT_PRIORITY = ["large","medium","small"];
const SRCSET_VARIANT_ORDER = ["small","medium","large"];
const normalizeImageSource = (value) => {
  if (typeof value !== "string") return null;
  const trimmed = value.trim();
  return trimmed.length > 0 ? trimmed : null;
};
const readDerivedRoot = (item) => {
  const derived = item?.media?.derived;
  return derived && typeof derived === "object" ? derived : null;
};
const readDerivedVariantSource = (item, variant) => {
  const root = readDerivedRoot(item);
  const value = root ? root[variant] : null;
  const direct = normalizeImageSource(value);
  if (direct) return direct;
  if (!value || typeof value !== "object") return null;
  const entries = Object.entries(value);
  for (const format of IMAGE_DERIVED_FORMAT_PREFERENCE) {
    const match = entries.find(([key]) => String(key).trim().toLowerCase() === format);
    if (!match) continue;
    const source = normalizeImageSource(match[1]);
    if (source) return source;
  }
  for (const [, candidate] of entries) {
    const source = normalizeImageSource(candidate);
    if (source) return source;
  }
  return null;
};
const readLegacyResponsiveSource = (item, variant) =>
  normalizeImageSource(item?.media?.responsive?.[variant]);
const readAlternateScrollSource = (item) =>
  item?.media?.scrollAnimationMode === "alternate"
    ? normalizeImageSource(item?.media?.scrollAnimationSrc)
    : null;
const readOriginalHeroSource = (item) =>
  normalizeImageSource(item?.media?.originalHero360);
const pickPrioritySource = (item, priority) => {
  for (const variant of priority) {
    const source = readDerivedVariantSource(item, variant) || readLegacyResponsiveSource(item, variant);
    if (source) return source;
  }
  return normalizeImageSource(item?.media?.hero360) || "";
};
const buildSrcSet = (item) => {
  if (readAlternateScrollSource(item)) return "";
  const entries = SRCSET_VARIANT_ORDER.map((variant) => ({
    src: readDerivedVariantSource(item, variant) || readLegacyResponsiveSource(item, variant),
    width: RESPONSIVE_IMAGE_WIDTHS[variant]
  })).filter((entry) => Boolean(entry.src));
  if (entries.length === 0) return "";
  const unique = new Map();
  entries.forEach((entry) => {
    if (!unique.has(entry.src)) unique.set(entry.src, entry.width);
  });
  return Array.from(unique.entries()).map(([src, width]) => src + " " + width + "w").join(", ");
};
const getCarouselImageSrc = (item) =>
  readAlternateScrollSource(item) || pickPrioritySource(item, CAROUSEL_VARIANT_PRIORITY);
const getDetailImageSrc = (item) =>
  readOriginalHeroSource(item) || pickPrioritySource(item, DETAIL_VARIANT_PRIORITY);
const decodeMaybe = (value) => {
  try {
    return decodeURIComponent(value);
  } catch {
    return value;
  }
};
const getInteractiveAssetMime = (source) => {
  if (!source) return null;
  const candidates = [decodeMaybe(source.trim()).toLowerCase()];
  try {
    const url = new URL(source, window.location.href);
    const encodedPath = url.searchParams.get("path");
    if (encodedPath) {
      candidates.push(decodeMaybe(encodedPath).toLowerCase());
    }
  } catch {}
  for (const candidate of candidates) {
    if (/\.gif(?:$|[?#&])/i.test(candidate)) return "image/gif";
    if (/\.webp(?:$|[?#&])/i.test(candidate)) return "image/webp";
  }
  return null;
};
const getInteractiveDetailAsset = (item) => {
  const candidates = [
    item?.media?.originalHero360,
    item?.media?.hero360,
    item?.media?.responsive?.large,
    item?.media?.responsive?.medium,
    item?.media?.responsive?.small
  ];
  for (const candidate of candidates) {
    const source = (candidate || "").trim();
    if (!source) continue;
    const mime = getInteractiveAssetMime(source);
    if (mime) return { source, mime };
  }
  return null;
};
const supportsInteractiveMedia = () => "ImageDecoder" in window;
const getDishRotateDirection = (dish) => (dish?.media?.rotationDirection === "cw" ? -1 : 1);
const INTERACTIVE_CENTER_SAMPLE_TARGET = 6;
  const readForegroundCenterFromBitmap = (bitmap) => {
    const maxSize = 140;
    const scale = Math.min(1, maxSize / Math.max(bitmap.width, bitmap.height));
    const width = Math.max(1, Math.round(bitmap.width * scale));
    const height = Math.max(1, Math.round(bitmap.height * scale));
    const offscreen = document.createElement("canvas");
  offscreen.width = width;
  offscreen.height = height;
  const ctx = offscreen.getContext("2d", { willReadFrequently: true });
  if (!ctx) return null;
  ctx.drawImage(bitmap, 0, 0, width, height);
  const { data } = ctx.getImageData(0, 0, width, height);
  const alphaThreshold = 16;

  const readAlphaBounds = () => {
    let minX = width;
    let minY = height;
    let maxX = -1;
    let maxY = -1;
    for (let y = 0; y < height; y += 1) {
      for (let x = 0; x < width; x += 1) {
        const idx = (y * width + x) * 4;
        if (data[idx + 3] <= alphaThreshold) continue;
        if (x < minX) minX = x;
        if (x > maxX) maxX = x;
        if (y < minY) minY = y;
        if (y > maxY) maxY = y;
      }
    }
    if (maxX < 0 || maxY < 0) return null;
    return { minX, minY, maxX, maxY };
  };

  let r = 0;
  let g = 0;
  let b = 0;
  let r2 = 0;
  let g2 = 0;
  let b2 = 0;
  let samples = 0;
  const sampleEdge = (x, y) => {
    const idx = (y * width + x) * 4;
    if (data[idx + 3] <= alphaThreshold) return;
    const rv = data[idx];
    const gv = data[idx + 1];
    const bv = data[idx + 2];
    r += rv;
    g += gv;
    b += bv;
    r2 += rv * rv;
    g2 += gv * gv;
    b2 += bv * bv;
    samples += 1;
  };
  for (let x = 0; x < width; x += 1) {
    sampleEdge(x, 0);
    if (height > 1) sampleEdge(x, height - 1);
  }
  for (let y = 1; y < height - 1; y += 1) {
    sampleEdge(0, y);
    if (width > 1) sampleEdge(width - 1, y);
  }
  if (samples === 0) {
    const bounds = readAlphaBounds();
    if (!bounds) return null;
    const centerX = (bounds.minX + bounds.maxX) / 2;
    const centerY = (bounds.minY + bounds.maxY) / 2;
    const invScale = scale > 0 ? 1 / scale : 1;
    return {
      center: { x: centerX * invScale, y: centerY * invScale },
      bounds: {
        minX: bounds.minX * invScale,
        minY: bounds.minY * invScale,
        maxX: bounds.maxX * invScale,
        maxY: bounds.maxY * invScale
      }
    };
  }
  const meanR = r / samples;
  const meanG = g / samples;
  const meanB = b / samples;
  const varR = Math.max(0, r2 / samples - meanR * meanR);
  const varG = Math.max(0, g2 / samples - meanG * meanG);
  const varB = Math.max(0, b2 / samples - meanB * meanB);
  const colorStd = Math.sqrt(varR + varG + varB);
  const threshold = Math.max(12, Math.min(60, colorStd * 2.6 + 10));
  const thresholdSq = threshold * threshold;

  const isBackground = (idx) => {
    if (data[idx + 3] <= alphaThreshold) return true;
    const dr = data[idx] - meanR;
    const dg = data[idx + 1] - meanG;
    const db = data[idx + 2] - meanB;
    return dr * dr + dg * dg + db * db <= thresholdSq;
  };

  const pixelTotal = width * height;
  const visited = new Uint8Array(pixelTotal);
  const queue = [];
  const pushIfBackground = (x, y) => {
    if (x < 0 || y < 0 || x >= width || y >= height) return;
    const idx = y * width + x;
    if (visited[idx]) return;
    if (!isBackground(idx * 4)) return;
    visited[idx] = 1;
    queue.push(idx);
  };

  for (let x = 0; x < width; x += 1) {
    pushIfBackground(x, 0);
    if (height > 1) pushIfBackground(x, height - 1);
  }
  for (let y = 1; y < height - 1; y += 1) {
    pushIfBackground(0, y);
    if (width > 1) pushIfBackground(width - 1, y);
  }

  while (queue.length) {
    const idx = queue.pop() ?? 0;
    const x = idx % width;
    const y = Math.floor(idx / width);
    pushIfBackground(x + 1, y);
    pushIfBackground(x - 1, y);
    pushIfBackground(x, y + 1);
    pushIfBackground(x, y - 1);
  }

  let minX = width;
  let minY = height;
  let maxX = -1;
  let maxY = -1;
  const rowCounts = new Uint32Array(height);
  const colCounts = new Uint32Array(width);
  let foregroundTotal = 0;
  for (let y = 0; y < height; y += 1) {
    for (let x = 0; x < width; x += 1) {
      const idx = y * width + x;
      if (visited[idx]) continue;
      const dataIdx = idx * 4;
      if (data[dataIdx + 3] <= alphaThreshold) continue;
      if (x < minX) minX = x;
      if (x > maxX) maxX = x;
      if (y < minY) minY = y;
      if (y > maxY) maxY = y;
      rowCounts[y] += 1;
      colCounts[x] += 1;
      foregroundTotal += 1;
    }
  }
  if (maxX < 0 || maxY < 0) {
    const bounds = readAlphaBounds();
    if (!bounds) return null;
    minX = bounds.minX;
    minY = bounds.minY;
    maxX = bounds.maxX;
    maxY = bounds.maxY;
  } else if (foregroundTotal > 0) {
    const trimCount = Math.max(1, Math.round(foregroundTotal * 0.01));
    const findMinIndex = (counts) => {
      let acc = 0;
      for (let i = 0; i < counts.length; i += 1) {
        acc += counts[i];
        if (acc >= trimCount) return i;
      }
      return 0;
    };
    const findMaxIndex = (counts) => {
      let acc = 0;
      for (let i = counts.length - 1; i >= 0; i -= 1) {
        acc += counts[i];
        if (acc >= trimCount) return i;
      }
      return counts.length - 1;
    };
    const trimmedMinY = findMinIndex(rowCounts);
    const trimmedMaxY = findMaxIndex(rowCounts);
    const trimmedMinX = findMinIndex(colCounts);
    const trimmedMaxX = findMaxIndex(colCounts);
    const baseW = maxX - minX;
    const baseH = maxY - minY;
    const trimmedW = trimmedMaxX - trimmedMinX;
    const trimmedH = trimmedMaxY - trimmedMinY;
    if (trimmedW > baseW * 0.4 && trimmedH > baseH * 0.4) {
      minX = Math.min(Math.max(trimmedMinX, 0), width - 1);
      maxX = Math.min(Math.max(trimmedMaxX, minX), width - 1);
      minY = Math.min(Math.max(trimmedMinY, 0), height - 1);
      maxY = Math.min(Math.max(trimmedMaxY, minY), height - 1);
    }
  }
  const centerX = (minX + maxX) / 2;
  const centerY = (minY + maxY) / 2;
  const invScale = scale > 0 ? 1 / scale : 1;
  return {
    center: { x: centerX * invScale, y: centerY * invScale },
    bounds: {
      minX: minX * invScale,
      minY: minY * invScale,
      maxX: maxX * invScale,
      maxY: maxY * invScale
    }
  };
};
const readCenterOffsetFromBitmaps = (bitmaps) => {
  if (!bitmaps.length) return null;
  const sampleTarget = Math.min(INTERACTIVE_CENTER_SAMPLE_TARGET, bitmaps.length);
  const step = Math.max(1, Math.floor(bitmaps.length / sampleTarget));
  const centers = [];
  for (let index = 0; index < bitmaps.length && centers.length < sampleTarget; index += step) {
    const info = readForegroundCenterFromBitmap(bitmaps[index]);
    if (info) centers.push(info.center);
  }
  if (!centers.length) return null;
  const xs = centers.map((center) => center.x).sort((a, b) => a - b);
  const ys = centers.map((center) => center.y).sort((a, b) => a - b);
  const medianX = xs[Math.floor(xs.length / 2)];
  const medianY = ys[Math.floor(ys.length / 2)];
  const width = bitmaps[0].width;
  const height = bitmaps[0].height;
  return {
    x: Math.round(width / 2 - medianX),
    y: Math.round(height / 2 - medianY)
  };
};
const readContentBoundsFromBitmaps = (bitmaps) => {
  if (!bitmaps.length) return null;
  const sampleTarget = Math.min(INTERACTIVE_CENTER_SAMPLE_TARGET, bitmaps.length);
  const step = Math.max(1, Math.floor(bitmaps.length / sampleTarget));
  const boundsList = [];
  for (let index = 0; index < bitmaps.length && boundsList.length < sampleTarget; index += step) {
    const info = readForegroundCenterFromBitmap(bitmaps[index]);
    if (info) boundsList.push(info.bounds);
  }
  if (!boundsList.length) return null;
  const median = (values) => {
    const sorted = [...values].sort((a, b) => a - b);
    return sorted[Math.floor(sorted.length / 2)];
  };
  const minX = median(boundsList.map((b) => b.minX));
  const minY = median(boundsList.map((b) => b.minY));
  const maxX = median(boundsList.map((b) => b.maxX));
  const maxY = median(boundsList.map((b) => b.maxY));
  return { minX, minY, maxX, maxY };
};
const getInteractiveAssetBytes = async (source) => {
  const cached = interactiveDetailBytesCache.get(source);
  if (cached) return cached;
  const pending = interactiveDetailBytesPending.get(source);
  if (pending) return pending;
  const task = (async () => {
    try {
      const response = await fetch(source, { cache: "force-cache" });
      if (!response.ok) return null;
      const bytes = await response.arrayBuffer();
      interactiveDetailBytesCache.set(source, bytes);
      return bytes;
    } catch {
      return null;
    } finally {
      interactiveDetailBytesPending.delete(source);
    }
  })();
  interactiveDetailBytesPending.set(source, task);
  return task;
};
const prefetchDishDetailItem = (dish) => {
  if (!dish) return;
  const detailSource = (getDetailImageSrc(dish) || "").trim();
  if (detailSource && !detailPrefetchedSources.has(detailSource)) {
    detailPrefetchedSources.add(detailSource);
    const preload = new Image();
    preload.decoding = "async";
    preload.src = detailSource;
  }
  const interactiveAsset = getInteractiveDetailAsset(dish);
  if (
    interactiveAsset &&
    supportsInteractiveMedia() &&
    !detailPrefetchedSources.has(interactiveAsset.source)
  ) {
    detailPrefetchedSources.add(interactiveAsset.source);
    void getInteractiveAssetBytes(interactiveAsset.source);
  }
};
const prefetchDishDetailByIds = (categoryId, itemId, includeNeighbors = false) => {
  const category = DATA.categories.find((entry) => entry.id === categoryId);
  if (!category || !category.items?.length) return;
  const index = category.items.findIndex((entry) => entry.id === itemId);
  if (index < 0) return;
  const targets = [index];
  if (includeNeighbors && category.items.length > 1) {
    targets.push((index - 1 + category.items.length) % category.items.length);
    targets.push((index + 1) % category.items.length);
  }
  Array.from(new Set(targets)).forEach((target) => {
    prefetchDishDetailItem(category.items[target]);
  });
};
const teardownInteractiveModalMedia = () => {
  modalMediaToken += 1;
  if (modalMediaCleanup) {
    modalMediaCleanup();
    modalMediaCleanup = null;
  }
};
const setupInteractiveModalMedia = async (asset) => {
  teardownInteractiveModalMedia();
  if (!asset || !modalContent) return;
  const Decoder = window.ImageDecoder;
  if (!Decoder) return;
  const host = modalContent.querySelector(".dish-modal__media");
  const image = host?.querySelector("img");
  if (!host || !image) return;
  const token = ++modalMediaToken;
  const abortController = new AbortController();
  let disposed = false;
  let decoder = null;
  const bitmaps = [];
  let canvas = null;
  let ctx = null;
  let canvasDisplayWidth = 0;
  let canvasDisplayHeight = 0;
  let resizeObserver = null;
  let pointerId = null;
  let lastX = 0;
  let frameCursor = 0;
  let interactiveReady = false;
  let imageHidden = false;
  const allowAutoCenter = !INTERACTIVE_KEEP_ORIGINAL_PLACEMENT;
  let centerOffset = allowAutoCenter
    ? interactiveDetailCenterOffsetCache.get(asset.source) || { x: 0, y: 0 }
    : { x: 0, y: 0 };
  let contentBounds = null;
  let renderSpec = null;
  const debugEnabled = DEBUG_INTERACTIVE_CENTER;
  let debugEl = null;
  let debugBounds = null;
  let debugVisibleRect = null;
  let debugFrameSize = null;
  const cueElement = host.querySelector(".dish-modal__rotate-cue");
  let cueIdleTimeout = 0;
  const clearCueTimers = () => {
    if (cueIdleTimeout) {
      window.clearTimeout(cueIdleTimeout);
      cueIdleTimeout = 0;
    }
  };
  const restartCueLoop = () => {
    if (!cueElement) return;
    cueElement.style.setProperty("--rotate-cue-loop-ms", ROTATE_CUE_LOOP_MS + "ms");
    cueElement.classList.remove("is-looping");
    void cueElement.offsetWidth;
    cueElement.classList.add("is-looping");
  };
  const setCueState = (state) => {
    host.dataset.cueState = state;
    if (state === "visible") {
      restartCueLoop();
    }
  };
  const scheduleCueVisible = () => {
    if (disposed) return;
    if (cueIdleTimeout) {
      window.clearTimeout(cueIdleTimeout);
    }
    cueIdleTimeout = window.setTimeout(() => {
      cueIdleTimeout = 0;
      if (disposed) return;
      setCueState("visible");
    }, ROTATE_CUE_RESHOW_IDLE_MS);
  };
  host.classList.add("is-loading-interactive");
  setCueState("visible");
  if (debugEnabled) {
    debugEl = document.createElement("div");
    debugEl.className = "dish-modal__media-debug";
    host.appendChild(debugEl);
  }
  const hideImage = () => {
    if (imageHidden) return;
    imageHidden = true;
    image.classList.add("is-hidden");
  };
  const updateDebugOverlay = () => {
    if (!debugEnabled || !debugEl) return;
    const frameLabel = canvas ? canvas.width + "x" + canvas.height : "-";
    const offsetLabel = Math.round(centerOffset.x) + ", " + Math.round(centerOffset.y);
    const boundsLabel = debugBounds
      ? Math.round(debugBounds.minX) +
        "," +
        Math.round(debugBounds.minY) +
        " " +
        Math.round(debugBounds.maxX - debugBounds.minX) +
        "x" +
        Math.round(debugBounds.maxY - debugBounds.minY)
      : "-";
    const visibleLabel = debugVisibleRect
      ? Math.round(debugVisibleRect.x) +
        "," +
        Math.round(debugVisibleRect.y) +
        " " +
        Math.round(debugVisibleRect.width) +
        "x" +
        Math.round(debugVisibleRect.height)
      : "-";
    const frameSizeLabel = debugFrameSize
      ? Math.round(debugFrameSize.width) + "x" + Math.round(debugFrameSize.height)
      : "-";
    debugEl.textContent =
      "offset: " +
      offsetLabel +
      "\nframe: " +
      frameLabel +
      "\nsource: " +
      frameSizeLabel +
      "\nvisible: " +
      visibleLabel +
      "\nbounds: " +
      boundsLabel;
  };
  const cleanup = () => {
    if (disposed) return;
    disposed = true;
    abortController.abort();
    if (resizeObserver) {
      resizeObserver.disconnect();
      resizeObserver = null;
    }
    if (canvas) {
      canvas.remove();
    }
    if (debugEl) {
      debugEl.remove();
      debugEl = null;
    }
    if (imageHidden) {
      image.classList.remove("is-hidden");
    }
    clearCueTimers();
    cueElement?.classList.remove("is-looping");
    delete host.dataset.cueState;
    host.classList.remove("is-loading-interactive");
    host.classList.remove("is-interactive");
    bitmaps.forEach((bitmap) => bitmap.close?.());
    bitmaps.length = 0;
    try {
      decoder?.close?.();
    } catch {}
  };
  modalMediaCleanup = cleanup;
  try {
    const bytes = await getInteractiveAssetBytes(asset.source);
    if (!bytes) {
      cleanup();
      return;
    }
    if (disposed || token !== modalMediaToken) {
      cleanup();
      return;
    }
    decoder = new Decoder({ data: bytes, type: asset.mime });
    await decoder.tracks.ready;
    const frameCount = Number(decoder.tracks?.selectedTrack?.frameCount ?? 0);
    if (frameCount < 2) {
      cleanup();
      return;
    }
    const frameStep = Math.max(1, Math.ceil(frameCount / INTERACTIVE_GIF_MAX_FRAMES));
    const decodeIndices = [];
    for (let frameIndex = 0; frameIndex < frameCount; frameIndex += frameStep) {
      decodeIndices.push(frameIndex);
    }
    if (decodeIndices[decodeIndices.length - 1] !== frameCount - 1) {
      decodeIndices.push(frameCount - 1);
    }
    const pixelsPerFrame = window.matchMedia("(pointer: coarse)").matches ? 7 : 4;
    const computeRenderSpec = () => {
      if (!canvas || !contentBounds) return null;
      const dpr = window.devicePixelRatio || 1;
      const width = canvasDisplayWidth || canvas.width / dpr;
      const height = canvasDisplayHeight || canvas.height / dpr;
      const boundsW = Math.max(1, contentBounds.maxX - contentBounds.minX);
      const boundsH = Math.max(1, contentBounds.maxY - contentBounds.minY);
      const padding = Math.max(boundsW, boundsH) * 0.08;
      let sx = contentBounds.minX - padding;
      let sy = contentBounds.minY - padding;
      let sw = boundsW + padding * 2;
      let sh = boundsH + padding * 2;

      sx = Math.max(0, Math.min(sx, width - 1));
      sy = Math.max(0, Math.min(sy, height - 1));
      sw = Math.max(1, Math.min(sw, width));
      sh = Math.max(1, Math.min(sh, height));
      if (sx + sw > width) {
        sx = Math.max(0, width - sw);
      }
      if (sy + sh > height) {
        sy = Math.max(0, height - sh);
      }

      const scale = Math.min(width / sw, height / sh);
      const dw = sw * scale;
      const dh = sh * scale;
      const dx = (width - dw) / 2;
      const dy = (height - dh) / 2;
      return { sx, sy, sw, sh, dx, dy, dw, dh };
    };
  const render = () => {
    if (!canvas || !ctx || disposed) return;
    const dpr = window.devicePixelRatio || 1;
    const displayWidth = canvasDisplayWidth || canvas.width / dpr;
    const displayHeight = canvasDisplayHeight || canvas.height / dpr;
    const frameCountSafe = Math.max(1, bitmaps.length);
    const normalized =
      ((Math.round(frameCursor) % frameCountSafe) + frameCountSafe) % frameCountSafe;
    const frame = bitmaps[normalized];
    if (!frame) return;
    ctx.clearRect(0, 0, displayWidth, displayHeight);
    let containScale = 1;
    let containDx = 0;
    let containDy = 0;
    if (renderSpec) {
      ctx.drawImage(
        frame,
        renderSpec.sx,
        renderSpec.sy,
        renderSpec.sw,
        renderSpec.sh,
        renderSpec.dx,
        renderSpec.dy,
        renderSpec.dw,
        renderSpec.dh
      );
    } else {
      containScale = Math.min(displayWidth / frame.width, displayHeight / frame.height);
      const dw = frame.width * containScale;
      const dh = frame.height * containScale;
      containDx = (displayWidth - dw) / 2;
      containDy = (displayHeight - dh) / 2;
      ctx.drawImage(frame, containDx, containDy, dw, dh);
    }
      if (debugEnabled && debugBounds) {
        let rectX = debugBounds.minX + centerOffset.x;
        let rectY = debugBounds.minY + centerOffset.y;
        let rectW = debugBounds.maxX - debugBounds.minX;
        let rectH = debugBounds.maxY - debugBounds.minY;
        if (renderSpec) {
          const scaleX = renderSpec.dw / renderSpec.sw;
          const scaleY = renderSpec.dh / renderSpec.sh;
          rectX = renderSpec.dx + (debugBounds.minX - renderSpec.sx) * scaleX;
          rectY = renderSpec.dy + (debugBounds.minY - renderSpec.sy) * scaleY;
          rectW = (debugBounds.maxX - debugBounds.minX) * scaleX;
          rectH = (debugBounds.maxY - debugBounds.minY) * scaleY;
        } else {
          rectX = containDx + debugBounds.minX * containScale;
          rectY = containDy + debugBounds.minY * containScale;
          rectW = (debugBounds.maxX - debugBounds.minX) * containScale;
          rectH = (debugBounds.maxY - debugBounds.minY) * containScale;
        }
        const centerX = displayWidth / 2;
        const centerY = displayHeight / 2;
        const boundsCenterX = rectX + rectW / 2;
        const boundsCenterY = rectY + rectH / 2;
        ctx.save();
        ctx.strokeStyle = "rgba(248, 250, 252, 0.7)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(centerX - 12, centerY);
        ctx.lineTo(centerX + 12, centerY);
        ctx.moveTo(centerX, centerY - 12);
        ctx.lineTo(centerX, centerY + 12);
        ctx.stroke();
        ctx.strokeStyle = "rgba(251, 191, 36, 0.85)";
        ctx.lineWidth = 2;
        ctx.strokeRect(rectX, rectY, rectW, rectH);
        ctx.fillStyle = "rgba(34, 197, 94, 0.9)";
        ctx.beginPath();
        ctx.arc(boundsCenterX, boundsCenterY, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
      updateDebugOverlay();
    };
    const ensureCanvas = (firstBitmap) => {
      if (canvas || disposed) return;
      if (allowAutoCenter) {
        const computedOffset = readCenterOffsetFromBitmaps(bitmaps);
        if (computedOffset) {
          centerOffset = computedOffset;
          interactiveDetailCenterOffsetCache.set(asset.source, centerOffset);
        }
      }
      canvas = document.createElement("canvas");
      canvas.className = "dish-modal__media-canvas";
      canvas.width = firstBitmap.width;
      canvas.height = firstBitmap.height;
      ctx = canvas.getContext("2d");
      if (!ctx) {
        cleanup();
        return;
      }
      if (allowAutoCenter && contentBounds) {
        renderSpec = computeRenderSpec();
      }
      const onPointerDown = (event) => {
        pointerId = event.pointerId;
        lastX = event.clientX;
        clearCueTimers();
        setCueState("hidden");
        canvas.setPointerCapture(pointerId);
        canvas.classList.add("is-dragging");
        event.preventDefault();
      };
      const onPointerMove = (event) => {
        if (pointerId !== event.pointerId) return;
        const deltaX = event.clientX - lastX;
        lastX = event.clientX;
        setCueState("hidden");
        frameCursor += (deltaX / pixelsPerFrame) * detailRotateDirection;
        render();
        event.preventDefault();
      };
      const onPointerRelease = (event) => {
        if (pointerId !== event.pointerId) return;
        try {
          canvas.releasePointerCapture(pointerId);
        } catch {}
        pointerId = null;
        canvas.classList.remove("is-dragging");
        setCueState("hidden");
        scheduleCueVisible();
      };
      canvas.addEventListener("pointerdown", onPointerDown);
      canvas.addEventListener("pointermove", onPointerMove);
      canvas.addEventListener("pointerup", onPointerRelease);
      canvas.addEventListener("pointercancel", onPointerRelease);
      canvas.addEventListener("contextmenu", (event) => event.preventDefault());
      canvas.addEventListener("dragstart", (event) => event.preventDefault());

      host.appendChild(canvas);
      const syncCanvasToImage = () => {
        if (!canvas || !ctx) return;
        const imageRect = image.getBoundingClientRect();
        const hostRect = host.getBoundingClientRect();
        const width = imageRect.width;
        const height = imageRect.height;
        if (!width || !height) {
          requestAnimationFrame(syncCanvasToImage);
          return;
        }
        canvasDisplayWidth = width;
        canvasDisplayHeight = height;
        canvas.style.position = "absolute";
        canvas.style.left = imageRect.left - hostRect.left + "px";
        canvas.style.top = imageRect.top - hostRect.top + "px";
        canvas.style.width = width + "px";
        canvas.style.height = height + "px";
        const dpr = window.devicePixelRatio || 1;
        canvas.width = Math.max(1, Math.round(width * dpr));
        canvas.height = Math.max(1, Math.round(height * dpr));
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      };
      syncCanvasToImage();
      requestAnimationFrame(syncCanvasToImage);
      if (!resizeObserver && "ResizeObserver" in window) {
        resizeObserver = new ResizeObserver(() => {
          syncCanvasToImage();
          render();
        });
        resizeObserver.observe(host);
      }
      hideImage();
      host.classList.remove("is-loading-interactive");
    };
    const normalizeDecodedFrame = async (frame) => {
      if (debugEnabled && !debugFrameSize) {
        debugFrameSize = {
          width: frame.codedWidth || frame.displayWidth || frame.visibleRect?.width || 0,
          height: frame.codedHeight || frame.displayHeight || frame.visibleRect?.height || 0
        };
      }
      const visibleRect = frame.visibleRect;
      if (debugEnabled && !debugVisibleRect && visibleRect) {
        debugVisibleRect = {
          x: visibleRect.x,
          y: visibleRect.y,
          width: visibleRect.width,
          height: visibleRect.height
        };
      }
      const fullWidth = frame.codedWidth || frame.displayWidth || visibleRect?.width || 0;
      const fullHeight = frame.codedHeight || frame.displayHeight || visibleRect?.height || 0;
      if (!visibleRect || !fullWidth || !fullHeight) {
        return createImageBitmap(frame);
      }
      const sameBounds =
        Math.round(visibleRect.x) === 0 &&
        Math.round(visibleRect.y) === 0 &&
        Math.round(visibleRect.width) === Math.round(fullWidth) &&
        Math.round(visibleRect.height) === Math.round(fullHeight);
      if (sameBounds) {
        return createImageBitmap(frame);
      }
      const offscreen = document.createElement("canvas");
      offscreen.width = fullWidth;
      offscreen.height = fullHeight;
      const offCtx = offscreen.getContext("2d");
      if (!offCtx) {
        return createImageBitmap(frame);
      }
      offCtx.clearRect(0, 0, fullWidth, fullHeight);
      offCtx.drawImage(
        frame,
        0,
        0,
        visibleRect.width,
        visibleRect.height,
        visibleRect.x,
        visibleRect.y,
        visibleRect.width,
        visibleRect.height
      );
      return createImageBitmap(offscreen);
    };
    let decodedCount = 0;
    for (const frameIndex of decodeIndices) {
      const decoded = await decoder.decode({ frameIndex, completeFramesOnly: true });
      const frame = decoded?.image;
      if (!frame) continue;
      const bitmap = await normalizeDecodedFrame(frame);
      frame.close?.();
      if (disposed || token !== modalMediaToken) {
        bitmap.close?.();
        cleanup();
        return;
      }
      bitmaps.push(bitmap);
      if (debugEnabled && !debugBounds) {
        const info = readForegroundCenterFromBitmap(bitmap);
        if (info) debugBounds = info.bounds;
      }
      if (
        allowAutoCenter &&
        (bitmaps.length === 1 || bitmaps.length === INTERACTIVE_CENTER_SAMPLE_TARGET)
      ) {
        const computedOffset = readCenterOffsetFromBitmaps(bitmaps);
        if (computedOffset) {
          const delta =
            Math.abs(computedOffset.x - centerOffset.x) +
            Math.abs(computedOffset.y - centerOffset.y);
          if (delta > 1) {
            centerOffset = computedOffset;
            interactiveDetailCenterOffsetCache.set(asset.source, centerOffset);
          }
        }
        const computedBounds = readContentBoundsFromBitmaps(bitmaps);
        if (computedBounds) {
          contentBounds = computedBounds;
          renderSpec = computeRenderSpec();
          if (debugEnabled) {
            debugBounds = computedBounds;
          }
        }
      }
      if (!canvas) {
        ensureCanvas(bitmap);
      }
      render();
      if (!interactiveReady && bitmaps.length >= 2) {
        interactiveReady = true;
        host.classList.add("is-interactive");
      }
      decodedCount += 1;
      if (decodedCount % 6 === 0) {
        await new Promise((resolve) => requestAnimationFrame(() => resolve(null)));
      }
    }
    if (!canvas) {
      cleanup();
      return;
    }
    if (allowAutoCenter) {
      const computedOffset = readCenterOffsetFromBitmaps(bitmaps);
      if (computedOffset) {
        centerOffset = computedOffset;
        interactiveDetailCenterOffsetCache.set(asset.source, centerOffset);
        render();
      }
      const computedBounds = readContentBoundsFromBitmaps(bitmaps);
      if (computedBounds) {
        contentBounds = computedBounds;
        renderSpec = computeRenderSpec();
        if (debugEnabled) {
          debugBounds = computedBounds;
        }
        render();
      }
    }
    if (!interactiveReady && bitmaps.length >= 2) {
      interactiveReady = true;
      host.classList.add("is-interactive");
    }
  } catch (error) {
    const isAbort = error instanceof DOMException && error.name === "AbortError";
    if (!isAbort) {
      console.warn("Interactive GIF decode failed", error);
    }
    cleanup();
  }
};
const instructionCopy = {
  en: {
    loadingLabel: "Loading assets",
    tapHint: "Tap or click an item for details",
    assetDisclaimer:
      "Assets belong to their owners. Do not copy or reuse this content without permission.",
    jukeboxHint: "Scroll vertically to spin the disc. Horizontal to switch sections.",
    focusRowsHint: "Scroll vertically for sections. Horizontally for items.",
    rotateHintTouch: "Swipe horizontally on the image to rotate",
    rotateHintMouse: "Drag horizontally with the mouse to rotate",
    rotateToggle: "Reverse rotation"
  },
  es: {
    loadingLabel: "Cargando assets",
    tapHint: "Toca o haz clic en un item para ver detalles",
    assetDisclaimer:
      "Los assets pertenecen a sus propietarios. No copies ni reutilices este contenido sin autorización.",
    jukeboxHint: "Desliza vertical para girar el disco. Horizontal para cambiar sección.",
    focusRowsHint: "Desliza vertical para secciones. Horizontal para items.",
    rotateHintTouch: "Desliza horizontal sobre la imagen para girar",
    rotateHintMouse: "Arrastra horizontal con el mouse para girar",
    rotateToggle: "Invertir giro"
  },
  fr: {
    loadingLabel: "Chargement des assets",
    tapHint: "Touchez ou cliquez sur un élément pour voir les détails",
    assetDisclaimer:
      "Les assets appartiennent à leurs propriétaires. Ne copiez ni ne réutilisez ce contenu sans autorisation.",
    jukeboxHint:
      "Faites défiler verticalement pour faire tourner le disque. Horizontalement pour changer de section.",
    focusRowsHint:
      "Faites défiler verticalement pour les sections. Horizontalement pour les éléments.",
    rotateHintTouch: "Balayez horizontalement l'image pour faire tourner",
    rotateHintMouse: "Faites glisser horizontalement avec la souris pour faire tourner",
    rotateToggle: "Inverser la rotation"
  },
  pt: {
    loadingLabel: "Carregando assets",
    tapHint: "Toque ou clique em um item para ver detalhes",
    assetDisclaimer:
      "Os assets pertencem aos seus proprietários. Não copie nem reutilize este conteúdo sem autorização.",
    jukeboxHint: "Deslize verticalmente para girar o disco. Horizontalmente para mudar de seção.",
    focusRowsHint: "Deslize verticalmente para seções. Horizontalmente para itens.",
    rotateHintTouch: "Deslize horizontalmente na imagem para girar",
    rotateHintMouse: "Arraste horizontalmente com o mouse para girar",
    rotateToggle: "Inverter rotação"
  },
  it: {
    loadingLabel: "Caricamento assets",
    tapHint: "Tocca o fai clic su un articolo per vedere i dettagli",
    assetDisclaimer:
      "Gli assets appartengono ai rispettivi proprietari. Non copiare o riutilizzare questo contenuto senza autorizzazione.",
    jukeboxHint: "Scorri verticalmente per far girare il disco. Orizzontalmente per cambiare sezione.",
    focusRowsHint: "Scorri verticalmente per le sezioni. Orizzontalmente per gli articoli.",
    rotateHintTouch: "Scorri orizzontalmente sull'immagine per ruotare",
    rotateHintMouse: "Trascina orizzontalmente con il mouse per ruotare",
    rotateToggle: "Inverti rotazione"
  },
  de: {
    loadingLabel: "Assets werden geladen",
    tapHint: "Tippe oder klicke auf ein Element, um Details zu sehen",
    assetDisclaimer:
      "Assets gehören ihren Eigentümern. Bitte nicht ohne Genehmigung kopieren oder wiederverwenden.",
    jukeboxHint: "Vertikal scrollen, um die Scheibe zu drehen. Horizontal, um die Sektion zu wechseln.",
    focusRowsHint: "Vertikal für Sektionen scrollen. Horizontal für Elemente.",
    rotateHintTouch: "Wische horizontal über das Bild, um zu drehen",
    rotateHintMouse: "Ziehe horizontal mit der Maus, um zu drehen",
    rotateToggle: "Drehrichtung umkehren"
  },
  ja: {
    loadingLabel: "アセットを読み込み中",
    tapHint: "アイテムをタップまたはクリックして詳細を見る",
    assetDisclaimer:
      "アセットは各所有者に帰属します。許可なく複製・再利用しないでください。",
    jukeboxHint: "縦スクロールでディスクを回転。横スクロールでセクション切替。",
    focusRowsHint: "縦スクロールでセクション。横スクロールでアイテム。",
    rotateHintTouch: "画像上で横にスワイプして回転",
    rotateHintMouse: "画像上で横にドラッグして回転",
    rotateToggle: "回転方向を反転"
  },
  ko: {
    loadingLabel: "에셋 로딩 중",
    tapHint: "아이템을 탭하거나 클릭해 상세 정보를 확인하세요",
    assetDisclaimer:
      "에셋은 각 소유자에게 귀속됩니다. 허가 없이 복사하거나 재사용하지 마세요.",
    jukeboxHint: "세로 스크롤로 디스크를 회전. 가로 스크롤로 섹션 전환.",
    focusRowsHint: "세로 스크롤로 섹션. 가로 스크롤로 아이템.",
    rotateHintTouch: "이미지에서 가로로 스와이프해 회전",
    rotateHintMouse: "마우스로 가로로 드래그해 회전",
    rotateToggle: "회전 방향 반전"
  },
  zh: {
    loadingLabel: "正在加载素材",
    tapHint: "点按或点击项目查看详情",
    assetDisclaimer: "素材归其所有者所有。未经许可请勿复制或再利用。",
    jukeboxHint: "纵向滚动旋转转盘，横向滚动切换分类。",
    focusRowsHint: "纵向滚动浏览分类，横向滚动浏览项目。",
    rotateHintTouch: "在图片上横向滑动以旋转",
    rotateHintMouse: "用鼠标横向拖动以旋转",
    rotateToggle: "反向旋转"
  }
};

const normalizeLocale = (value) => (value || "").toLowerCase().split("-")[0];

const getInstructionCopy = (key) => {
  const localeKey = normalizeLocale(locale);
  const pack = instructionCopy[localeKey] || instructionCopy.en;
  return pack[key] || instructionCopy.en[key];
};

const getLoadingLabel = () => getInstructionCopy("loadingLabel");
const getTapHint = () => getInstructionCopy("tapHint");
const getAssetDisclaimer = () => getInstructionCopy("assetDisclaimer");
const getJukeboxHint = () => getInstructionCopy("jukeboxHint");
const getFocusRowsHint = () => getInstructionCopy("focusRowsHint");
const normalizeTemplateToken = (value) =>
  String(value || "")
    .trim()
    .toLowerCase()
    .replace(/[_\s]+/g, "-");
const resolveTemplateId = (value) => {
  const normalized = normalizeTemplateToken(value);
  if (normalized === "jukebox" || normalized === "juke-box") return "jukebox";
  if (
    normalized === "focus-rows" ||
    normalized === "focusrows" ||
    normalized === "focus-row" ||
    normalized === "in-focus-rows" ||
    normalized === "bar-pub" ||
    normalized === "cafe-brunch" ||
    normalized === "street-food"
  ) {
    return "focus-rows";
  }
  return "focus-rows";
};
const activeTemplateId = resolveTemplateId(DATA.meta.template || "focus-rows");
const isJukeboxTemplate = () => activeTemplateId === "jukebox";
const STARTUP_BLOCKING_BACKGROUND_LIMIT = 1;
const STARTUP_BLOCKING_ITEM_LIMIT = 3;
const normalizeStartupSourceKey = (value) =>
  String(value || "").trim().replace(/^\/+/, "").split(/[?#]/, 1)[0];
const estimateStartupAssetBytes = (source) => {
  const key = normalizeStartupSourceKey(source).toLowerCase();
  const isBackground = key.includes("/backgrounds/");
  const isGif = key.endsWith(".gif");
  const isWebp = key.endsWith(".webp");
  const isAvif = key.endsWith(".avif");
  const isPng = key.endsWith(".png");
  const isJpeg = key.endsWith(".jpg") || key.endsWith(".jpeg");
  if (isBackground) {
    if (isGif) return 1300000;
    if (isWebp) return 650000;
    if (isAvif) return 420000;
    if (isPng || isJpeg) return 700000;
    return 900000;
  }
  if (isGif) return 650000;
  if (isWebp) return 260000;
  if (isAvif) return 180000;
  if (isPng || isJpeg) return 320000;
  return 300000;
};
const readStartupAssetBytes = (source) => {
  const key = normalizeStartupSourceKey(source);
  const bytes = startupAssetBytes.get(key);
  if (typeof bytes === "number" && Number.isFinite(bytes) && bytes > 0) {
    return Math.round(bytes);
  }
  return estimateStartupAssetBytes(source);
};
const sortSourcesByStartupWeight = (sources) =>
  [...sources].sort((left, right) => readStartupAssetBytes(left) - readStartupAssetBytes(right));
const loadStartupAssetBytes = async () => {
  if (startupAssetBytesReady) return;
  if (startupAssetBytesPromise) return startupAssetBytesPromise;
  startupAssetBytesPromise = (async () => {
    try {
      const response = await fetch("asset-manifest.json", { cache: "force-cache" });
      if (!response.ok) return;
      const payload = await response.json();
      const assets = Array.isArray(payload?.assets) ? payload.assets : [];
      assets.forEach((entry) => {
        const outputPath = typeof entry?.outputPath === "string" ? entry.outputPath : "";
        const bytes = Number(entry?.bytes);
        if (!outputPath || !Number.isFinite(bytes) || bytes <= 0) return;
        startupAssetBytes.set(normalizeStartupSourceKey(outputPath), Math.round(bytes));
      });
    } catch {
      // Ignore diagnostics loading failures; fallback estimates will be used.
    } finally {
      startupAssetBytesReady = true;
      startupAssetBytesPromise = null;
    }
  })();
  return startupAssetBytesPromise;
};
const collectStartupItemPrioritySources = () => {
  const rows = DATA.categories.map((category) =>
    category.items
      .map((item) => (getCarouselImageSrc(item) || "").trim())
      .filter((src) => src.length > 0)
  );
  const ordered = [];
  let depth = 0;
  while (true) {
    let foundAtDepth = false;
    rows.forEach((row) => {
      const src = row[depth];
      if (!src) return;
      ordered.push(src);
      foundAtDepth = true;
    });
    if (!foundAtDepth) break;
    depth += 1;
  }
  const deduped = [];
  const seen = new Set();
  ordered.forEach((src) => {
    if (seen.has(src)) return;
    seen.add(src);
    deduped.push(src);
  });
  return deduped;
};
const buildStartupSourcePlan = () => {
  const backgroundSources = [];
  const backgroundSeen = new Set();
  backgrounds.forEach((bg) => {
    const src = (bg?.src || "").trim();
    if (!src || backgroundSeen.has(src)) return;
    backgroundSeen.add(src);
    backgroundSources.push(src);
  });
  const itemSources = collectStartupItemPrioritySources();
  const backgroundBlockingCandidates = sortSourcesByStartupWeight(backgroundSources);
  const itemBlockingCandidates = sortSourcesByStartupWeight(itemSources);
  const blocking = [];
  const blockingSet = new Set();
  backgroundBlockingCandidates.slice(0, STARTUP_BLOCKING_BACKGROUND_LIMIT).forEach((src) => {
    if (blockingSet.has(src)) return;
    blockingSet.add(src);
    blocking.push(src);
  });
  itemBlockingCandidates.slice(0, STARTUP_BLOCKING_ITEM_LIMIT).forEach((src) => {
    if (blockingSet.has(src)) return;
    blockingSet.add(src);
    blocking.push(src);
  });
  const all = [];
  const seen = new Set();
  [...backgroundSources, ...itemSources].forEach((src) => {
    if (!src || seen.has(src)) return;
    seen.add(src);
    all.push(src);
  });
  const deferred = all.filter((src) => !blockingSet.has(src));
  return { blocking, deferred };
};
const preloadImageAsset = (src) =>
  new Promise((resolve) => {
    if (!src) {
      resolve();
      return;
    }
    const image = new Image();
    const done = () => resolve();
    image.onload = done;
    image.onerror = done;
    image.src = src;
    if (image.complete) {
      resolve();
    }
  });
const preloadImageBatch = async (sources, onProgress, concurrency = 4) => {
  if (!sources.length) return;
  const queue = sources.slice();
  const workers = Math.max(1, Math.min(concurrency, queue.length));
  let loaded = 0;
  const runWorker = async () => {
    while (queue.length > 0) {
      const source = queue.shift();
      if (!source) continue;
      await preloadImageAsset(source);
      loaded += 1;
      onProgress?.(source, loaded, sources.length);
    }
  };
  await Promise.all(Array.from({ length: workers }, () => runWorker()));
};
const preloadDeferredAssets = (sources) => {
  if (!sources.length) return;
  const run = () => {
    void preloadImageBatch(sources, null, 3);
  };
  if ("requestIdleCallback" in window && typeof window.requestIdleCallback === "function") {
    window.requestIdleCallback(() => run(), { timeout: 900 });
    return;
  }
  window.setTimeout(run, 120);
};
const syncStartupUi = () => {
  const preview = app.querySelector(".menu-preview");
  const loader = app.querySelector(".menu-startup-loader");
  const fill = app.querySelector(".menu-startup-loader__fill");
  const value = app.querySelector(".menu-startup-loader__value");
  preview?.classList.toggle("is-loading", startupLoading);
  loader?.classList.toggle("active", startupLoading);
  if (fill) fill.style.width = startupProgress + "%";
  if (value) value.textContent = Math.round(startupProgress) + "%";
};
const preloadStartupAssets = async () => {
  const token = ++startupToken;
  await loadStartupAssetBytes();
  const plan = buildStartupSourcePlan();
  startupBlockingSourceSet = new Set(plan.blocking);
  refreshVisibleCarouselMedia();
  if (plan.blocking.length === 0) {
    startupProgress = 100;
    startupLoading = false;
    startupBlockingSourceSet = new Set();
    syncStartupUi();
    refreshVisibleCarouselMedia();
    preloadDeferredAssets(plan.deferred);
    return;
  }
  const totalWeight = Math.max(
    1,
    plan.blocking.reduce((sum, source) => sum + readStartupAssetBytes(source), 0)
  );
  let loadedWeight = 0;
  startupLoading = true;
  startupProgress = 0;
  syncStartupUi();
  await preloadImageBatch(
    plan.blocking,
    (source) => {
      if (token !== startupToken) return;
      loadedWeight += readStartupAssetBytes(source);
      startupProgress = Math.max(
        1,
        Math.min(100, Math.round((loadedWeight / totalWeight) * 100))
      );
      syncStartupUi();
    },
    4
  );
  if (token !== startupToken) return;
  startupProgress = 100;
  startupLoading = false;
  startupBlockingSourceSet = new Set();
  syncStartupUi();
  refreshVisibleCarouselMedia();
  preloadDeferredAssets(plan.deferred);
};

const buildCarousel = (category) => {
  const entries = isJukeboxTemplate()
    ? getJukeboxItems(category.items)
    : getFocusRowItems(category.items);
  return `
    <div class="menu-section__head">
      <p class="menu-section__title">${textOf(category.name)}</p>
      <span class="menu-section__count">${category.items.length} items</span>
    </div>
    ${category.items.length > 1 && !isJukeboxTemplate()
      ? '<div class="carousel-nav">' +
        '<button class="carousel-nav__btn prev" type="button" data-category-id="' +
        category.id +
        '" data-dir="-1" aria-label="Previous item"><span aria-hidden="true">‹</span></button>' +
        '<button class="carousel-nav__btn next" type="button" data-category-id="' +
        category.id +
        '" data-dir="1" aria-label="Next item"><span aria-hidden="true">›</span></button>' +
        "</div>"
      : ""}
    <div class="menu-carousel ${category.items.length <= 1 ? "single" : ""}" data-category-id="${category.id}">
      ${entries
        .map((entry) => {
          const srcSet = buildSrcSet(entry.item);
          const priceHtml =
            entry.item.priceVisible === false
              ? ""
              : '<span class="carousel-price">' + formatPrice(entry.item.price.amount) + "</span>";
          return `
            <button class="carousel-card" type="button" style="${getItemFontStyle(entry.item)}" data-item="${entry.item.id}" data-source="${entry.sourceIndex}">
              <div class="carousel-media is-loaded">
                <span class="carousel-media__loader" aria-hidden="true"></span>
                <img src="${TRANSPARENT_PIXEL_SRC}" data-media-src="${getCarouselImageSrc(entry.item)}" ${srcSet ? 'data-media-srcset="' + srcSet + '"' : ""} sizes="(max-width: 640px) 64vw, (max-width: 1200px) 34vw, 260px" alt="${textOf(entry.item.name)}" draggable="false" oncontextmenu="return false;" ondragstart="return false;" loading="lazy" decoding="async" fetchpriority="low" />
              </div>
              <div class="carousel-text">
                <div class="carousel-row">
                  <p class="carousel-title">${textOf(entry.item.name)}${entry.item.vegan ? '<span class="vegan-icon" title="' + getTerm("vegan") + '">🌿</span>' : ""}</p>
                  ${priceHtml}
                </div>
                <p class="carousel-desc">${textOf(entry.item.description)}</p>
              </div>
            </button>
          `;
        })
        .join("")}
    </div>
  `;
};

const render = () => {
  const restaurantName =
    DATA.meta.restaurantName?.[locale] ??
    DATA.meta.restaurantName?.[DATA.meta.defaultLocale] ??
    "";
  const menuTitle =
    DATA.meta.title?.[locale] ??
    DATA.meta.title?.[DATA.meta.defaultLocale] ??
    "";
  const identityMode = DATA.meta.identityMode === "logo" ? "logo" : "text";
  const logoSrc = (DATA.meta.logoSrc || "").trim();
  const logoAlt = (restaurantName || menuTitle || "Restaurant").replace(/"/g, "&quot;");
  const templateClass = "template-" + activeTemplateId;
  const backgroundModeClass =
    backgroundDisplayMode === "section" ? "background-mode-section" : "background-mode-carousel";
  ensureFont();
  app.innerHTML = `
    <div class="menu-preview ${templateClass} ${backgroundModeClass} ${startupLoading ? "is-loading" : ""}">
      <div class="menu-startup-loader ${startupLoading ? "active" : ""}">
        <div class="menu-startup-loader__card">
          <p class="menu-startup-loader__label">${getLoadingLabel()}</p>
          <div class="menu-startup-loader__track">
            <span class="menu-startup-loader__fill" style="width:${startupProgress}%"></span>
          </div>
          <p class="menu-startup-loader__value">${Math.round(startupProgress)}%</p>
        </div>
      </div>
      ${backgrounds
        .map(
          (item, index) =>
            `<div class="menu-background ${index === activeBackgroundIndex ? "active" : ""}" data-bg-src="${item.src}"></div>`
        )
        .join("")}
      <div class="menu-overlay"></div>
      <header class="menu-topbar">
        <div class="menu-title-block">
          ${identityMode === "logo" && logoSrc
            ? '<img class="menu-logo" src="' + logoSrc + '" alt="' + logoAlt + '" decoding="async" />'
            : (restaurantName ? '<p class="menu-eyebrow">' + restaurantName + "</p>" : "")}
          <h1 class="menu-title">${menuTitle || "Menu"}</h1>
        </div>
        <div class="menu-lang">
          <select class="menu-select" id="menu-locale">
            ${DATA.meta.locales
              .map((lang) => `<option value="${lang}" ${lang === locale ? "selected" : ""}>${lang.toUpperCase()}</option>`)
              .join("")}
          </select>
        </div>
      </header>
      ${isJukeboxTemplate() &&
      DATA.categories.length > 1 &&
      window.matchMedia("(min-width: 900px)").matches
        ? '<div class="section-nav">' +
          '<button class="section-nav__btn prev" type="button" data-section-dir="-1" aria-label="Previous section"><span aria-hidden="true">‹</span></button>' +
          '<span class="section-nav__label">' + getJukeboxHint() + "</span>" +
          '<button class="section-nav__btn next" type="button" data-section-dir="1" aria-label="Next section"><span aria-hidden="true">›</span></button>' +
          "</div>"
        : ""}
      ${!isJukeboxTemplate()
        ? '<div class="focus-rows-hint" aria-hidden="true"><span class="focus-rows-hint__label">' +
          getFocusRowsHint() +
          "</span></div>"
        : ""}
      <div class="menu-scroll">
        ${DATA.categories
          .map(
            (category) =>
              `<section class="menu-section">${buildCarousel(
                category
              )}</section>`
          )
          .join("")}
      </div>
      <div class="menu-tap-hint" aria-hidden="true">
        <span class="menu-tap-hint__dot"></span>
        <span>${getTapHint()}</span>
      </div>
      <p class="menu-asset-disclaimer" aria-hidden="true">${getAssetDisclaimer()}</p>
    </div>
  `;
  const preview = app.querySelector(".menu-preview");
  if (preview) {
    const interfaceFont = getInterfaceFontConfig();
    const identityFont = getRoleFontConfig("identity");
    const restaurantFont = getRoleFontConfig("restaurant");
    const titleFont = getRoleFontConfig("title");
    const sectionFont = getRoleFontConfig("section");
    const itemFont = getRoleFontConfig("item");
    preview.style.setProperty("--menu-font", getFontStack(interfaceFont.family));
    preview.style.setProperty("--menu-font-ui", getFontStack(interfaceFont.family));
    preview.style.setProperty("--menu-font-identity", getFontStack(identityFont.family));
    preview.style.setProperty("--menu-font-restaurant", getFontStack(restaurantFont.family));
    preview.style.setProperty("--menu-font-title", getFontStack(titleFont.family));
    preview.style.setProperty("--menu-font-section", getFontStack(sectionFont.family));
    preview.style.setProperty("--menu-font-item", getFontStack(itemFont.family));
    preview.addEventListener("contextmenu", (event) => event.preventDefault());
    preview.addEventListener("dragstart", (event) => {
      const target = event.target;
      if (target instanceof HTMLImageElement) {
        event.preventDefault();
      }
    });
  }
  applyBackgroundState = () => {
    const layers = Array.from(app.querySelectorAll(".menu-background"));
    const warmIndexes = [];
    if (backgrounds.length > 0 && activeBackgroundIndex >= 0) {
      warmIndexes.push(activeBackgroundIndex);
      if (backgrounds.length > 1) {
        warmIndexes.push((activeBackgroundIndex + 1) % backgrounds.length);
      }
    }
    layers.forEach((layer, index) => {
      layer.classList.toggle("active", index === activeBackgroundIndex);
      if (!warmIndexes.includes(index)) return;
      if (layer.dataset.bgLoaded === "1") return;
      const source = (layer.dataset.bgSrc || "").trim();
      if (!source) return;
      layer.style.backgroundImage = "url('" + source.replace(/'/g, "\\'") + "')";
      layer.dataset.bgLoaded = "1";
    });
  };
  const startBackgroundRotation = () => {
    if (backgroundTimer) {
      window.clearInterval(backgroundTimer);
      backgroundTimer = undefined;
    }
    if (backgroundDisplayMode === "section") {
      const scroll = app.querySelector(".menu-scroll");
      if (scroll) {
        const sectionIndex = isJukeboxTemplate()
          ? getClosestHorizontalSectionIndex(scroll)
          : getClosestSectionIndex(scroll);
        if (sectionIndex >= 0) {
          syncBackgroundForSectionIndex(sectionIndex);
        } else {
          activeBackgroundIndex = -1;
        }
      } else {
        activeBackgroundIndex = -1;
      }
      applyBackgroundState();
      return;
    }
    if (backgrounds.length < 2) {
      applyBackgroundState();
      return;
    }
    backgroundTimer = window.setInterval(() => {
      activeBackgroundIndex = (activeBackgroundIndex + 1) % backgrounds.length;
      applyBackgroundState();
    }, backgroundRotationMs);
  };
  applyBackgroundState();
  startBackgroundRotation();
  const localeSelect = document.getElementById("menu-locale");
  localeSelect?.addEventListener("change", (event) => {
    locale = event.target.value;
    render();
  });
  bindCarousels();
  bindCarouselNav();
  bindSectionNav();
  bindSectionFocus();
  bindCards();
  syncStartupUi();
};

const applyFocusState = (container, activeIndex, itemCount = 0) => {
  const cards = Array.from(container.querySelectorAll(".carousel-card"));
  const count = itemCount || cards.length || 1;
  const hideAt = Math.max(1.6, count / 2 - 0.25);
  if (isJukeboxTemplate()) {
    cards.forEach((card, index) => {
      const sourceIndex = Number(card.dataset.source || index);
      const offset = getCircularOffset(activeIndex, sourceIndex, count);
      const distance = Math.abs(offset);
      const wheelRadius = 420;
      const stepY = 210;
      const discBiasX = -72;
      const rawY = offset * stepY;
      const clampedY = Math.max(-wheelRadius, Math.min(wheelRadius, rawY));
      const chord = Math.sqrt(Math.max(0, wheelRadius * wheelRadius - clampedY * clampedY));
      const arcX = distance < 0.5 ? discBiasX : discBiasX - (wheelRadius - chord);
      const focusShift = distance < 0.5 ? -arcX : 0;
      const arcY = clampedY;
      const scale = distance < 0.5 ? 1 : 0.88;
      const opacity = distance < 0.5 ? 1 : distance <= 1.2 ? 0.82 : 0;
      const depth = Math.max(1, 220 - Math.round(distance * 26));
      card.style.setProperty("--arc-x", arcX.toFixed(1) + "px");
      card.style.setProperty("--arc-y", arcY.toFixed(1) + "px");
      card.style.setProperty("--card-scale", scale.toFixed(3));
      card.style.setProperty("--card-opacity", opacity.toFixed(3));
      card.style.setProperty("--focus-shift", focusShift.toFixed(1) + "px");
      card.style.setProperty("--ring-depth", String(depth));
      card.classList.toggle("active", Math.abs(offset) < 0.5);
      card.classList.toggle("near", Math.abs(offset) >= 0.5 && Math.abs(offset) < 1.25);
      card.classList.toggle("far", Math.abs(offset) >= 1.25);
      card.classList.toggle("is-hidden", distance >= hideAt);
      maybeHydrateCarouselCardMedia(card, distance);
    });
    return;
  }

  cards.forEach((card, index) => {
    const sourceIndex = Number(card.dataset.source || index);
    const offset = getCircularOffset(activeIndex, sourceIndex, count);
    const distance = Math.abs(offset);
    const stepX = 220;
    const maxDistance = 2.6;
    const x = offset * stepX;
    const y = Math.min(18, distance * 6);
    const scale = distance < 0.5 ? 1 : Math.max(0.68, 1 - distance * 0.14);
    let opacity =
      distance < 0.5 ? 1 : distance <= maxDistance ? Math.max(0, 1 - distance * 0.34) : 0;
    if (distance >= hideAt) {
      opacity = 0;
    }
    const blur = Math.min(8, distance * 2.4);
    const depth = Math.max(1, 120 - Math.round(distance * 18));
    card.style.setProperty("--row-x", x.toFixed(1) + "px");
    card.style.setProperty("--row-y", y.toFixed(1) + "px");
    card.style.setProperty("--row-scale", scale.toFixed(3));
    card.style.setProperty("--row-opacity", opacity.toFixed(3));
    card.style.setProperty("--row-blur", blur.toFixed(2) + "px");
    card.style.setProperty("--row-depth", String(depth));
    card.classList.toggle("active", distance < 0.5);
    card.classList.toggle("near", distance >= 0.5 && distance < 1.5);
    card.classList.toggle("far", distance >= 1.5 && distance < 2.5);
    card.classList.toggle("is-hidden", distance >= hideAt);
    maybeHydrateCarouselCardMedia(card, distance);
  });
};

const refreshVisibleCarouselMedia = () => {
  const carousels = Array.from(document.querySelectorAll(".menu-carousel"));
  carousels.forEach((container) => {
    const id = container.dataset.categoryId;
    const category = DATA.categories.find((item) => item.id === id);
    const count = category?.items.length || 0;
    if (count === 0) return;
    const active = Number(container.dataset.activeIndex || "0") || 0;
    applyFocusState(container, active, count);
  });
};

const shiftCarousel = (categoryId, direction) => {
  const container = app.querySelector(
    '.menu-carousel[data-category-id="' + categoryId + '"]'
  );
  if (!container) return;
  const category = DATA.categories.find((item) => item.id === categoryId);
  const count = category?.items.length || 0;
  if (count === 0) return;
  const current = Math.round(Number(container.dataset.activeIndex || "0") || 0);
  const next = wrapCarouselIndex(current + direction, count);
  container.dataset.activeIndex = String(next);
  applyFocusState(container, next, count);
};

const bindCarouselNav = () => {
  const buttons = Array.from(app.querySelectorAll(".carousel-nav__btn"));
  buttons.forEach((button) => {
    const handler = () => {
      const categoryId = button.dataset.categoryId;
      if (!categoryId) return;
      const direction = Number(button.dataset.dir || "1");
      shiftCarousel(categoryId, direction);
    };
    button.addEventListener("click", handler);
    carouselCleanup.push(() => {
      button.removeEventListener("click", handler);
    });
  });
};

const getClosestHorizontalSectionIndex = (container) => {
  const sections = Array.from(container.querySelectorAll(".menu-section"));
  if (sections.length === 0) return -1;
  const center = container.scrollLeft + container.clientWidth / 2;
  let closest = 0;
  let minDistance = Number.POSITIVE_INFINITY;
  sections.forEach((section, index) => {
    const sectionCenter = section.offsetLeft + section.offsetWidth / 2;
    const distance = Math.abs(sectionCenter - center);
    if (distance < minDistance) {
      minDistance = distance;
      closest = index;
    }
  });
  return closest;
};

const centerSectionHorizontally = (container, index, behavior = "smooth") => {
  const sections = Array.from(container.querySelectorAll(".menu-section"));
  const target = sections[index];
  if (!target || container.clientWidth === 0) return;
  const targetLeft = target.offsetLeft + target.offsetWidth / 2 - container.clientWidth / 2;
  container.scrollTo({ left: targetLeft, behavior });
};

const recoilResetTimers = new WeakMap();
const triggerSectionBoundaryRecoil = (container, axis, direction) => {
  if (!container) return;
  const activeTimer = recoilResetTimers.get(container);
  if (activeTimer) {
    window.clearTimeout(activeTimer);
  }
  const offset = (axis === "horizontal" ? 18 : 14) * -Math.sign(direction || 1);
  container.classList.add("menu-scroll--recoil");
  container.style.setProperty("--menu-recoil-x", axis === "horizontal" ? offset + "px" : "0px");
  container.style.setProperty("--menu-recoil-y", axis === "vertical" ? offset + "px" : "0px");
  requestAnimationFrame(() => {
    container.style.setProperty("--menu-recoil-x", "0px");
    container.style.setProperty("--menu-recoil-y", "0px");
  });
  const timer = window.setTimeout(() => {
    container.classList.remove("menu-scroll--recoil");
    container.style.removeProperty("--menu-recoil-x");
    container.style.removeProperty("--menu-recoil-y");
    recoilResetTimers.delete(container);
  }, 190);
  recoilResetTimers.set(container, timer);
};

const shiftSection = (direction) => {
  const container = app.querySelector(".menu-scroll");
  if (!container) return;
  const sections = Array.from(container.querySelectorAll(".menu-section"));
  if (sections.length <= 1) return;
  const current = isJukeboxTemplate()
    ? getClosestHorizontalSectionIndex(container)
    : getClosestSectionIndex(container);
  if (current < 0) return;
  const next = Math.min(sections.length - 1, Math.max(0, current + direction));
  if (next === current) {
    triggerSectionBoundaryRecoil(
      container,
      isJukeboxTemplate() ? "horizontal" : "vertical",
      direction
    );
    return;
  }
  if (isJukeboxTemplate()) {
    centerSectionHorizontally(container, next, "smooth");
    syncBackgroundForSectionIndex(next);
    return;
  }
  centerSection(container, next, "smooth");
  applySectionFocus(container);
  syncBackgroundForSectionIndex(next);
};

const isEditableKeyboardTarget = (target) => {
  if (!(target instanceof HTMLElement)) return false;
  if (target.isContentEditable) return true;
  const tag = target.tagName;
  if (tag === "INPUT" || tag === "TEXTAREA" || tag === "SELECT") return true;
  return Boolean(
    target.closest("input, textarea, select, [contenteditable='true'], [contenteditable='']")
  );
};

const getActiveSectionCategoryId = () => {
  if (!DATA.categories.length) return null;
  const container = app.querySelector(".menu-scroll");
  if (!container) return DATA.categories[0]?.id || null;
  const index = isJukeboxTemplate()
    ? getClosestHorizontalSectionIndex(container)
    : getClosestSectionIndex(container);
  if (index < 0) return DATA.categories[0]?.id || null;
  return DATA.categories[index]?.id || DATA.categories[0]?.id || null;
};

const handleKeyboardNavigation = (event) => {
  if (event.defaultPrevented) return;
  if (event.metaKey || event.ctrlKey || event.altKey) return;
  if (isEditableKeyboardTarget(event.target)) return;

  if (event.key === "Escape") {
    if (modal?.classList.contains("open")) {
      event.preventDefault();
      closeModal();
    }
    return;
  }

  if (!window.matchMedia("(min-width: 900px)").matches) return;
  if (modal?.classList.contains("open")) return;

  const categoryId = getActiveSectionCategoryId();
  if (!categoryId) return;

  if (isJukeboxTemplate()) {
    if (event.key === "ArrowLeft") {
      event.preventDefault();
      shiftSection(-1);
      return;
    }
    if (event.key === "ArrowRight") {
      event.preventDefault();
      shiftSection(1);
      return;
    }
    if (event.key === "ArrowUp") {
      event.preventDefault();
      shiftCarousel(categoryId, -1);
      return;
    }
    if (event.key === "ArrowDown") {
      event.preventDefault();
      shiftCarousel(categoryId, 1);
    }
    return;
  }

  if (event.key === "ArrowUp") {
    event.preventDefault();
    shiftSection(-1);
    return;
  }
  if (event.key === "ArrowDown") {
    event.preventDefault();
    shiftSection(1);
    return;
  }
  if (event.key === "ArrowLeft") {
    event.preventDefault();
    shiftCarousel(categoryId, -1);
    return;
  }
  if (event.key === "ArrowRight") {
    event.preventDefault();
    shiftCarousel(categoryId, 1);
  }
};

const bindSectionNav = () => {
  const buttons = Array.from(app.querySelectorAll(".section-nav__btn"));
  buttons.forEach((button) => {
    const handler = () => {
      const direction = Number(button.dataset.sectionDir || "1");
      shiftSection(direction);
    };
    button.addEventListener("click", handler);
    carouselCleanup.push(() => {
      button.removeEventListener("click", handler);
    });
  });
};

const bindCarousels = () => {
  carouselCleanup.forEach((dispose) => dispose());
  carouselCleanup = [];
  const carousels = Array.from(document.querySelectorAll(".menu-carousel"));
  carousels.forEach((container) => {
    const id = container.dataset.categoryId;
    const category = DATA.categories.find((item) => item.id === id);
    const count = category?.items.length || 0;
    if (count === 0) return;
    if (isJukeboxTemplate()) {
      const start = 0;
      container.dataset.activeIndex = String(start);
      applyFocusState(container, start, count);
      const state = jukeboxWheelState.get(id) || {
        settle: 0,
        touch: null,
        sectionCarry: 0,
        sectionLockUntil: 0,
        sectionGestureUntil: 0,
        sectionGestureConsumed: false
      };
      jukeboxWheelState.set(id, state);
      const queueSnap = () => {
        if (state.settle) window.clearTimeout(state.settle);
        state.settle = window.setTimeout(() => {
          const activeIndex = Number(container.dataset.activeIndex || "0") || 0;
          const normalized = wrapCarouselIndex(Math.round(activeIndex), count);
          container.dataset.activeIndex = String(normalized);
          applyFocusState(container, normalized, count);
          state.settle = 0;
        }, JUKEBOX_WHEEL_SETTLE_MS);
      };
      const applyDelta = (delta) => {
        if (!delta) return;
        const cappedDelta =
          JUKEBOX_MAX_STEP_PER_INPUT > 0
            ? Math.max(
                -JUKEBOX_WHEEL_STEP_THRESHOLD * JUKEBOX_MAX_STEP_PER_INPUT,
                Math.min(JUKEBOX_WHEEL_STEP_THRESHOLD * JUKEBOX_MAX_STEP_PER_INPUT, delta)
              )
            : delta;
        if (!cappedDelta) return;
        const current = Number(container.dataset.activeIndex || "0") || 0;
        const next = wrapCarouselIndex(
          current + cappedDelta / JUKEBOX_WHEEL_STEP_THRESHOLD,
          count
        );
        container.dataset.activeIndex = String(next);
        applyFocusState(container, next, count);
        queueSnap();
      };
      const onWheel = (event) => {
        const absX = Math.abs(event.deltaX);
        const absY = Math.abs(event.deltaY);
        if (absX <= 1 && absY <= 1) return;
        const horizontalDelta =
          absX >= JUKEBOX_HORIZONTAL_WHEEL_MIN_PX ? event.deltaX : event.shiftKey ? event.deltaY : 0;
        const verticalIntent =
          !event.shiftKey &&
          absY >= JUKEBOX_VERTICAL_WHEEL_MIN_PX &&
          (absX < JUKEBOX_HORIZONTAL_WHEEL_MIN_PX || absY >= absX * JUKEBOX_VERTICAL_DOMINANCE_RATIO);
        const horizontalIntent =
          Math.abs(horizontalDelta) >= JUKEBOX_HORIZONTAL_WHEEL_MIN_PX && !verticalIntent;
        if (horizontalIntent) {
          event.preventDefault();
          const now = Date.now();
          const inGesture = now <= (state.sectionGestureUntil || 0);
          state.sectionGestureUntil = now + JUKEBOX_HORIZONTAL_GESTURE_IDLE_MS;
          if (!inGesture) {
            state.sectionCarry = 0;
            state.sectionGestureConsumed = false;
          }
          if (state.sectionGestureConsumed) return;
          if (now < (state.sectionLockUntil || 0)) return;
          state.sectionCarry = (state.sectionCarry || 0) + horizontalDelta;
          if (Math.abs(state.sectionCarry) < JUKEBOX_HORIZONTAL_SECTION_THRESHOLD_PX) return;
          const direction = state.sectionCarry > 0 ? 1 : -1;
          const menuScroll = app.querySelector(".menu-scroll");
          const sections = menuScroll
            ? Array.from(menuScroll.querySelectorAll(".menu-section"))
            : [];
          const currentIndex = menuScroll ? getClosestHorizontalSectionIndex(menuScroll) : -1;
          if (
            sections.length > 0 &&
            currentIndex >= 0 &&
            ((direction < 0 && currentIndex <= 0) ||
              (direction > 0 && currentIndex >= sections.length - 1))
          ) {
            state.sectionCarry = 0;
            triggerSectionBoundaryRecoil(menuScroll, "horizontal", direction);
            return;
          }
          state.sectionCarry = 0;
          state.sectionGestureConsumed = true;
          state.sectionLockUntil = now + JUKEBOX_SECTION_WHEEL_COOLDOWN_MS;
          shiftSection(direction);
          return;
        }
        if (!verticalIntent) return;
        state.sectionCarry = 0;
        state.sectionGestureConsumed = false;
        state.sectionGestureUntil = 0;
        event.preventDefault();
        const delta = normalizeJukeboxWheelDelta(event);
        if (!delta) return;
        applyDelta(delta);
      };
      const onTouchStart = (event) => {
        const touch = event.changedTouches?.[0];
        if (!touch) return;
        state.touch = {
          id: touch.identifier,
          startX: touch.clientX,
          startY: touch.clientY,
          lastY: touch.clientY,
          axis: "pending"
        };
      };
      const onTouchMove = (event) => {
        if (!state.touch) return;
        const touch = Array.from(event.touches || []).find(
          (entry) => entry.identifier === state.touch.id
        );
        if (!touch) return;
        const totalDx = touch.clientX - state.touch.startX;
        const totalDy = touch.clientY - state.touch.startY;
        if (
          state.touch.axis === "pending" &&
          Math.max(Math.abs(totalDx), Math.abs(totalDy)) >= JUKEBOX_TOUCH_INTENT_THRESHOLD
        ) {
          state.touch.axis = Math.abs(totalDy) >= Math.abs(totalDx) ? "vertical" : "horizontal";
        }
        if (state.touch.axis !== "vertical") return;
        event.preventDefault();
        const deltaY = touch.clientY - state.touch.lastY;
        state.touch.lastY = touch.clientY;
        if (Math.abs(deltaY) < 0.2) return;
        applyDelta(-deltaY * JUKEBOX_TOUCH_DELTA_SCALE);
      };
      const clearTouch = (event) => {
        if (!state.touch) return;
        const ended = Array.from(event.changedTouches || []).some(
          (entry) => entry.identifier === state.touch.id
        );
        if (!ended) return;
        state.touch = null;
      };
      container.addEventListener("wheel", onWheel, { passive: false });
      container.addEventListener("touchstart", onTouchStart, { passive: true });
      container.addEventListener("touchmove", onTouchMove, { passive: false });
      container.addEventListener("touchend", clearTouch, { passive: true });
      container.addEventListener("touchcancel", clearTouch, { passive: true });
      carouselCleanup.push(() => {
        container.removeEventListener("wheel", onWheel);
        container.removeEventListener("touchstart", onTouchStart);
        container.removeEventListener("touchmove", onTouchMove);
        container.removeEventListener("touchend", clearTouch);
        container.removeEventListener("touchcancel", clearTouch);
        if (state.settle) {
          window.clearTimeout(state.settle);
        }
        state.touch = null;
        jukeboxWheelState.delete(id);
      });
      return;
    }
    const start = 0;
    container.dataset.activeIndex = String(start);
    applyFocusState(container, start, count);
    const state = focusRowWheelState.get(id) || { settle: 0, touch: null };
    focusRowWheelState.set(id, state);
    const queueSnap = () => {
      if (state.settle) window.clearTimeout(state.settle);
      state.settle = window.setTimeout(() => {
        const activeIndex = Number(container.dataset.activeIndex || "0") || 0;
        const normalized = wrapCarouselIndex(Math.round(activeIndex), count);
        container.dataset.activeIndex = String(normalized);
        applyFocusState(container, normalized, count);
        state.settle = 0;
      }, FOCUS_ROWS_WHEEL_SETTLE_MS);
    };
    const applyDelta = (delta) => {
      if (!delta) return;
      const cappedDelta =
        FOCUS_ROWS_MAX_STEP_PER_INPUT > 0
          ? Math.max(
              -FOCUS_ROWS_WHEEL_STEP_THRESHOLD * FOCUS_ROWS_MAX_STEP_PER_INPUT,
              Math.min(FOCUS_ROWS_WHEEL_STEP_THRESHOLD * FOCUS_ROWS_MAX_STEP_PER_INPUT, delta)
            )
          : delta;
      if (!cappedDelta) return;
      const current = Number(container.dataset.activeIndex || "0") || 0;
      const next = wrapCarouselIndex(current + cappedDelta / FOCUS_ROWS_WHEEL_STEP_THRESHOLD, count);
      container.dataset.activeIndex = String(next);
      applyFocusState(container, next, count);
      queueSnap();
    };
    const onWheel = (event) => {
      if (Math.abs(event.deltaX) <= Math.abs(event.deltaY)) return;
      event.preventDefault();
      const delta = normalizeFocusRowWheelDelta(event);
      if (!delta) return;
      applyDelta(delta);
    };
    const onTouchStart = (event) => {
      const touch = event.changedTouches?.[0];
      if (!touch) return;
      state.touch = {
        id: touch.identifier,
        startX: touch.clientX,
        startY: touch.clientY,
        lastX: touch.clientX,
        axis: "pending"
      };
    };
    const onTouchMove = (event) => {
      if (!state.touch) return;
      const touch = Array.from(event.touches || []).find(
        (entry) => entry.identifier === state.touch.id
      );
      if (!touch) return;
      const totalDx = touch.clientX - state.touch.startX;
      const totalDy = touch.clientY - state.touch.startY;
      if (
        state.touch.axis === "pending" &&
        Math.max(Math.abs(totalDx), Math.abs(totalDy)) >= FOCUS_ROWS_TOUCH_INTENT_THRESHOLD
      ) {
        state.touch.axis = Math.abs(totalDx) >= Math.abs(totalDy) ? "horizontal" : "vertical";
      }
      if (state.touch.axis !== "horizontal") return;
      event.preventDefault();
      const deltaX = touch.clientX - state.touch.lastX;
      state.touch.lastX = touch.clientX;
      if (Math.abs(deltaX) < 0.2) return;
      applyDelta(-deltaX * FOCUS_ROWS_TOUCH_DELTA_SCALE);
    };
    const clearTouch = (event) => {
      if (!state.touch) return;
      const ended = Array.from(event.changedTouches || []).some(
        (entry) => entry.identifier === state.touch.id
      );
      if (!ended) return;
      state.touch = null;
    };
    container.addEventListener("wheel", onWheel, { passive: false });
    container.addEventListener("touchstart", onTouchStart, { passive: true });
    container.addEventListener("touchmove", onTouchMove, { passive: false });
    container.addEventListener("touchend", clearTouch, { passive: true });
    container.addEventListener("touchcancel", clearTouch, { passive: true });
    carouselCleanup.push(() => {
      container.removeEventListener("wheel", onWheel);
      container.removeEventListener("touchstart", onTouchStart);
      container.removeEventListener("touchmove", onTouchMove);
      container.removeEventListener("touchend", clearTouch);
      container.removeEventListener("touchcancel", clearTouch);
      if (state.settle) {
        window.clearTimeout(state.settle);
      }
      state.touch = null;
      focusRowWheelState.delete(id);
    });
  });
};

const bindCards = () => {
  document.querySelectorAll(".carousel-card").forEach((card) => {
    const categoryId = card.closest(".menu-carousel")?.dataset.categoryId;
    const itemId = card.dataset.item;
    if (!categoryId || !itemId) return;
    const prefetch = () => prefetchDishDetailByIds(categoryId, itemId);
    card.addEventListener("pointerenter", prefetch);
    card.addEventListener("focus", prefetch);
    card.addEventListener("touchstart", prefetch, { passive: true });
    card.addEventListener("click", () => {
      const category = DATA.categories.find((item) => item.id === categoryId);
      const dish = category?.items.find((item) => item.id === itemId);
      if (!dish) return;
      prefetchDishDetailByIds(categoryId, itemId, true);
      const allergenLabel = getTerm("allergens");
      const veganLabel = getTerm("vegan");
      const longDesc = textOf(dish.longDescription);
      const allergens = getAllergenValues(dish).join(", ");
      const asset = getInteractiveDetailAsset(dish);
      detailRotateDirection = getDishRotateDirection(dish);
      modalContent.style.cssText = getItemFontStyle(dish);
      modalContent.innerHTML = `
        <div class="dish-modal__header">
          <p class="dish-modal__title">${textOf(dish.name)}</p>
          <button class="dish-modal__close" id="modal-close">✕</button>
        </div>
        <div class="dish-modal__media">
          ${asset && supportsInteractiveMedia() ? '<div class="dish-modal__rotate-cue" aria-hidden="true"><span class="dish-modal__rotate-cue-gesture"><svg class="dish-modal__rotate-cue-gesture-main" data-icon="gesture-swipe-horizontal" viewBox="0 0 24 24" role="presentation" focusable="false" aria-hidden="true"><path d="M6 1L3 4l3 3V5h3v2l3-3l-3-3v2H6zm5 7a1 1 0 0 0-1 1v10l-3.2-1.72h-.22c-.28 0-.55.11-.74.32l-.74.77l4.9 4.2c.26.28.62.43 1 .43h6.5a1.5 1.5 0 0 0 1.5-1.5v-4.36c0-.58-.32-1.11-.85-1.35l-4.94-2.19l-1.21-.13V9a1 1 0 0 0-1-1"></path></svg><svg class="dish-modal__rotate-cue-gesture-ghost" data-icon="gesture-swipe-horizontal" viewBox="0 0 24 24" role="presentation" focusable="false" aria-hidden="true"><path d="M6 1L3 4l3 3V5h3v2l3-3l-3-3v2H6zm5 7a1 1 0 0 0-1 1v10l-3.2-1.72h-.22c-.28 0-.55.11-.74.32l-.74.77l4.9 4.2c.26.28.62.43 1 .43h6.5a1.5 1.5 0 0 0 1.5-1.5v-4.36c0-.58-.32-1.11-.85-1.35l-4.94-2.19l-1.21-.13V9a1 1 0 0 0-1-1"></path></svg></span></div>' : ""}
          <img src="${getDetailImageSrc(dish)}" alt="${textOf(dish.name)}" draggable="false" oncontextmenu="return false;" ondragstart="return false;" decoding="async" />
        </div>
        <div class="dish-modal__content">
          <div class="dish-modal__text">
            <p class="dish-modal__desc">${textOf(dish.description)}</p>
            ${longDesc ? '<p class="dish-modal__long">' + longDesc + '</p>' : ""}
            ${allergens ? '<p class="dish-modal__allergens">' + allergenLabel + ': ' + allergens + '</p>' : ""}
            ${dish.vegan ? '<span class="dish-modal__badge">🌿 ' + veganLabel + '</span>' : ""}
          </div>
          ${dish.priceVisible === false ? "" : '<p class="dish-modal__price">' + formatPrice(dish.price.amount) + "</p>"}
        </div>
      `;
      modal.classList.add("open");
      if (asset && supportsInteractiveMedia()) {
        void setupInteractiveModalMedia(asset);
      }
      modal.querySelector("#modal-close")?.addEventListener("click", closeModal);
    });
  });
};

const getClosestSectionIndex = (container) => {
  const sections = Array.from(container.querySelectorAll(".menu-section"));
  if (sections.length === 0) return -1;
  const centerY = container.scrollTop + container.clientHeight / 2;
  let closest = 0;
  let minDistance = Number.POSITIVE_INFINITY;
  sections.forEach((section, index) => {
    const sectionCenter = section.offsetTop + section.offsetHeight / 2;
    const distance = Math.abs(sectionCenter - centerY);
    if (distance < minDistance) {
      minDistance = distance;
      closest = index;
    }
  });
  return closest;
};

const centerSection = (container, index, behavior = "smooth") => {
  const sections = Array.from(container.querySelectorAll(".menu-section"));
  const target = sections[index];
  if (!target || container.clientHeight === 0) return;
  const targetTop = target.offsetTop + target.offsetHeight / 2 - container.clientHeight / 2;
  container.scrollTo({ top: targetTop, behavior });
};

const applySectionFocus = (container) => {
  const sections = Array.from(container.querySelectorAll(".menu-section"));
  if (sections.length === 0) return;
  const centerY = container.scrollTop + container.clientHeight / 2;
  const maxDistance = Math.max(container.clientHeight * 0.6, 1);
  const closestIndex = getClosestSectionIndex(container);
  syncBackgroundForSectionIndex(closestIndex);
  sections.forEach((section, index) => {
    const sectionCenter = section.offsetTop + section.offsetHeight / 2;
    const distance = Math.abs(sectionCenter - centerY);
    const ratio = Math.min(1, distance / maxDistance);
    const focus = 1 - ratio * 0.14;
    section.style.setProperty("--section-focus", focus.toFixed(3));
    section.classList.toggle("is-centered", index === closestIndex);
  });
};

const bindSectionFocus = () => {
  const scroll = app.querySelector(".menu-scroll");
  if (!scroll) return;
  const sections = Array.from(scroll.querySelectorAll(".menu-section"));
  if (sections.length === 0) return;
  if (isJukeboxTemplate()) {
    if (scroll.scrollWidth <= scroll.clientWidth + 4) return;
    let snapTimeout;
    const onScroll = () => {
      if (snapTimeout) window.clearTimeout(snapTimeout);
      snapTimeout = window.setTimeout(() => {
        const snapIndex = getClosestHorizontalSectionIndex(scroll);
        if (snapIndex >= 0) {
          centerSectionHorizontally(scroll, snapIndex, "smooth");
          syncBackgroundForSectionIndex(snapIndex);
        }
      }, 170);
    };
    scroll.addEventListener("scroll", onScroll);
    carouselCleanup.push(() => {
      scroll.removeEventListener("scroll", onScroll);
      if (snapTimeout) window.clearTimeout(snapTimeout);
    });
    return;
  }
  applySectionFocus(scroll);
  if (scroll.scrollHeight <= scroll.clientHeight + 4) return;

  let raf;
  let snapTimeout;
  const onScroll = () => {
    if (raf) cancelAnimationFrame(raf);
    raf = requestAnimationFrame(() => {
      applySectionFocus(scroll);
    });
    if (snapTimeout) window.clearTimeout(snapTimeout);
    snapTimeout = window.setTimeout(() => {
      const closestIndex = getClosestSectionIndex(scroll);
      if (closestIndex >= 0) {
        centerSection(scroll, closestIndex, "smooth");
      }
      applySectionFocus(scroll);
    }, 180);
  };
  const onResize = () => {
    applySectionFocus(scroll);
  };

  scroll.addEventListener("scroll", onScroll);
  window.addEventListener("resize", onResize);
  window.addEventListener("orientationchange", onResize);
  carouselCleanup.push(() => {
    scroll.removeEventListener("scroll", onScroll);
    window.removeEventListener("resize", onResize);
    window.removeEventListener("orientationchange", onResize);
    if (raf) cancelAnimationFrame(raf);
    if (snapTimeout) window.clearTimeout(snapTimeout);
  });
};

const closeModal = () => {
  teardownInteractiveModalMedia();
  detailRotateDirection = -1;
  modal.classList.remove("open");
};

modal?.addEventListener("click", (event) => {
  if (event.target === modal) closeModal();
});
modal?.addEventListener("contextmenu", (event) => event.preventDefault());
modal?.addEventListener("dragstart", (event) => {
  if (event.target instanceof HTMLImageElement) {
    event.preventDefault();
  }
});
window.addEventListener("keydown", handleKeyboardNavigation);

render();
void preloadStartupAssets();
